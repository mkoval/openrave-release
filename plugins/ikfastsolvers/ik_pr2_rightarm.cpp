#define IKFAST_NAMESPACE ik_pr2_rightarm
#include "plugindefs.h"

/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 71 generated on 2014-04-13 19:20:38.967456
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==71);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#define IKFAST_STRINGIZE2(s) #s
#define IKFAST_STRINGIZE(s) IKFAST_STRINGIZE2(s)

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)
#endif

// used to check input to atan2 for degenerate cases
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62;
x0=IKcos(j[0]);
x1=IKsin(j[0]);
x2=IKsin(j[2]);
x3=IKcos(j[2]);
x4=IKsin(j[1]);
x5=IKsin(j[4]);
x6=IKcos(j[4]);
x7=IKcos(j[3]);
x8=IKcos(j[1]);
x9=IKsin(j[3]);
x10=IKcos(j[6]);
x11=IKsin(j[6]);
x12=IKsin(j[5]);
x13=IKcos(j[5]);
x14=((1.0)*x12);
x15=((0.18)*x7);
x16=((0.18)*x5);
x17=((0.321)*x3);
x18=((1.0)*x1);
x19=((0.18)*x9);
x20=((1.0)*x13);
x21=((1.0)*x9);
x22=((0.18)*x6);
x23=((1.0)*x3);
x24=(x8*x9);
x25=(x0*x8);
x26=(x0*x3);
x27=(x0*x2);
x28=(x4*x7);
x29=((-1.0)*x7);
x30=(x1*x4);
x31=(x1*x8);
x32=(x2*x8);
x33=(x31*x7);
x34=(x21*x25);
x35=(x18*x24);
x36=(x23*x7*x8);
x37=(((x27*x4))+(((-1.0)*x18*x3)));
x38=(x27+(((-1.0)*x18*x3*x4)));
x39=(((x2*x30))+x26);
x40=((((-1.0)*x36))+((x4*x9)));
x41=((((-1.0)*x18*x2))+(((-1.0)*x0*x23*x4)));
x42=(x37*x5);
x43=(x38*x7);
x44=(x39*x5);
x45=(((x21*x3*x8))+(((1.0)*x28)));
x46=(x38*x9);
x47=(x41*x7);
x48=(x41*x9);
x49=(((x32*x5))+((x40*x6)));
x50=((((-1.0)*x1*x24))+x43);
x51=(((x32*x6))+((x5*(((((-1.0)*x21*x4))+x36)))));
x52=((((-1.0)*x18*x7*x8))+(((-1.0)*x21*x38)));
x53=(x13*x49);
x54=((((-1.0)*x0*x24))+x47);
x55=(x50*x6);
x56=((((-1.0)*x48))+((x25*x29)));
x57=(x54*x6);
x58=(x44+x55);
x59=(((x6*(((((-1.0)*x34))+x47))))+x42);
x60=(((x5*((((x29*x38))+x35))))+((x39*x6)));
x61=(((x5*((((x29*x41))+x34))))+((x37*x6)));
x62=(x13*x59);
eerot[0]=(((x11*x61))+((x10*((((x12*x56))+x62)))));
eerot[1]=(((x11*(((((-1.0)*x20*x59))+(((-1.0)*x14*x56))))))+((x10*x61)));
eerot[2]=(((x13*((x48+((x25*x7))))))+((x12*((x42+x57)))));
eetrans[0]=(((x9*(((((-1.0)*x0*x17*x4))+(((-0.321)*x1*x2))))))+(((0.1)*x0))+(((0.321)*x25*x7))+(((0.4)*x25))+((x12*((((x16*x37))+((x22*x54))))))+((x13*((((x19*x41))+((x15*x25)))))));
eerot[3]=(((x11*x60))+((x10*((((x13*x58))+((x12*x52)))))));
eerot[4]=(((x11*(((((-1.0)*x20*x58))+(((-1.0)*x14*x52))))))+((x10*x60)));
eerot[5]=(((x13*((x33+x46))))+((x12*((((x6*(((((-1.0)*x35))+x43))))+x44)))));
eetrans[1]=((-0.188)+(((0.1)*x1))+((x13*((((x19*x38))+((x15*x31))))))+(((0.321)*x33))+(((0.4)*x31))+((x9*(((((-1.0)*x17*x30))+(((0.321)*x27))))))+((x12*((((x16*x39))+((x22*x50)))))));
eerot[6]=(((x11*x51))+((x10*((x53+((x12*x45)))))));
eerot[7]=(((x10*x51))+((x11*(((((-1.0)*x20*x49))+(((-1.0)*x14*x45)))))));
eerot[8]=(((x12*x49))+(((-1.0)*x13*x45)));
eetrans[2]=(((x13*(((((-1.0)*x19*x3*x8))+(((-1.0)*x15*x4))))))+((x12*((((x16*x32))+((x22*x40))))))+(((-1.0)*x17*x24))+(((-0.4)*x4))+(((-0.321)*x28)));
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {2}; return freeparams; }
IKFAST_API int GetNumJoints() { return 7; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j27,cj27,sj27,htj27,j27mul,j28,cj28,sj28,htj28,j28mul,j30,cj30,sj30,htj30,j30mul,j31,cj31,sj31,htj31,j31mul,j32,cj32,sj32,htj32,j32mul,j33,cj33,sj33,htj33,j33mul,j29,cj29,sj29,htj29,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij27[2], _nj27,_ij28[2], _nj28,_ij30[2], _nj30,_ij31[2], _nj31,_ij32[2], _nj32,_ij33[2], _nj33,_ij29[2], _nj29;

bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j27=numeric_limits<IkReal>::quiet_NaN(); _ij27[0] = -1; _ij27[1] = -1; _nj27 = -1; j28=numeric_limits<IkReal>::quiet_NaN(); _ij28[0] = -1; _ij28[1] = -1; _nj28 = -1; j30=numeric_limits<IkReal>::quiet_NaN(); _ij30[0] = -1; _ij30[1] = -1; _nj30 = -1; j31=numeric_limits<IkReal>::quiet_NaN(); _ij31[0] = -1; _ij31[1] = -1; _nj31 = -1; j32=numeric_limits<IkReal>::quiet_NaN(); _ij32[0] = -1; _ij32[1] = -1; _nj32 = -1; j33=numeric_limits<IkReal>::quiet_NaN(); _ij33[0] = -1; _ij33[1] = -1; _nj33 = -1;  _ij29[0] = -1; _ij29[1] = -1; _nj29 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j29=pfree[0]; cj29=cos(pfree[0]); sj29=sin(pfree[0]), htj29=tan(pfree[0]*0.5);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=r00;
new_r01=r01;
new_r02=r02;
new_px=((((-0.18)*r02))+px);
new_r10=r10;
new_r11=r11;
new_r12=r12;
new_py=((0.188)+(((-0.18)*r12))+py);
new_r20=r20;
new_r21=r21;
new_r22=r22;
new_pz=(pz+(((-0.18)*r22)));
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x63=((1.0)*px);
IkReal x64=((1.0)*pz);
IkReal x65=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x65))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x64)));
rxp0_2=((((-1.0)*r10*x63))+((py*r00)));
rxp1_0=((((-1.0)*r21*x65))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x64)));
rxp1_2=((((-1.0)*r11*x63))+((py*r01)));
rxp2_0=(((pz*r12))+(((-1.0)*r22*x65)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x64)));
rxp2_2=((((-1.0)*r12*x63))+((py*r02)));
IkReal op[8+1], zeror[8];
int numroots;
IkReal x66=((0.2)*px);
IkReal x67=((1.0)*pp);
IkReal x68=((0.509841)+x66+(((-1.0)*x67)));
IkReal x69=((-0.003759)+x66+(((-1.0)*x67)));
IkReal x70=(x66+x67);
IkReal x71=((0.509841)+(((-1.0)*x70)));
IkReal x72=((-0.003759)+(((-1.0)*x70)));
IkReal gconst0=x68;
IkReal gconst1=x69;
IkReal gconst2=x68;
IkReal gconst3=x69;
IkReal gconst4=x71;
IkReal gconst5=x72;
IkReal gconst6=x71;
IkReal gconst7=x72;
IkReal x73=py*py;
IkReal x74=sj29*sj29;
IkReal x75=px*px;
IkReal x76=((1.0)*gconst4);
IkReal x77=(gconst5*gconst7);
IkReal x78=(gconst0*gconst3);
IkReal x79=(gconst1*gconst2);
IkReal x80=((2.0)*gconst5);
IkReal x81=((1.0)*gconst0);
IkReal x82=(gconst1*gconst7);
IkReal x83=(gconst0*gconst6);
IkReal x84=(gconst1*gconst3);
IkReal x85=(gconst4*gconst7);
IkReal x86=((2.0)*gconst0);
IkReal x87=(gconst1*gconst6);
IkReal x88=(gconst0*gconst7);
IkReal x89=((2.0)*gconst4);
IkReal x90=(gconst3*gconst5);
IkReal x91=(gconst2*gconst5);
IkReal x92=(gconst3*gconst4);
IkReal x93=(gconst2*gconst4);
IkReal x94=(gconst4*gconst6);
IkReal x95=(gconst5*gconst6);
IkReal x96=(gconst0*gconst2);
IkReal x97=((1.05513984)*px*py);
IkReal x98=(gconst6*x73);
IkReal x99=((4.0)*px*py);
IkReal x100=((4.0)*x75);
IkReal x101=(gconst2*x73);
IkReal x102=(py*x74);
IkReal x103=((2.0)*x73);
IkReal x104=((1.0)*x73);
IkReal x105=((0.824328)*x74);
IkReal x106=((0.412164)*x74);
IkReal x107=(x73*x85);
IkReal x108=(x73*x95);
IkReal x109=(x73*x91);
IkReal x110=(x73*x92);
IkReal x111=(x73*x88);
IkReal x112=(x73*x87);
IkReal x113=((0.0834355125792)*x102);
IkReal x114=(x73*x79);
IkReal x115=(x73*x78);
IkReal x116=(x74*x91);
IkReal x117=(x73*x74);
IkReal x118=(x104*x77);
IkReal x119=(x76*x98);
IkReal x120=(x106*x95);
IkReal x121=(x93*x99);
IkReal x122=(x82*x99);
IkReal x123=(x90*x99);
IkReal x124=(x83*x99);
IkReal x125=(x92*x99);
IkReal x126=(x88*x99);
IkReal x127=(x91*x99);
IkReal x128=(x87*x99);
IkReal x129=(x106*x91);
IkReal x130=((0.06594624)*x117);
IkReal x131=(x104*x82);
IkReal x132=(x101*x76);
IkReal x133=(x81*x98);
IkReal x134=(x106*x87);
IkReal x135=(x104*x90);
IkReal x136=((0.3297312)*pp*x102);
IkReal x137=((0.06594624)*px*x102);
IkReal x138=(x101*x81);
IkReal x139=(x106*x79);
IkReal x140=(x104*x84);
IkReal x141=(x115+x114);
IkReal x142=(x108+x107);
IkReal x143=(x140+x139+x138);
IkReal x144=(x120+x119+x118);
IkReal x145=(x112+x111+x110+x109);
IkReal x146=(x126+x127+x125+x128);
IkReal x147=(x124+x122+x123+x121);
IkReal x148=(x135+x134+x131+x130+x133+x132+x129);
op[0]=((((-1.0)*x144))+x142);
op[1]=((((-1.0)*x113))+x137+x136+(((-1.0)*x97)));
op[2]=((((-1.0)*x148))+((x100*x95))+((x89*x98))+((x100*x85))+(((-1.0)*x103*x85))+(((-1.0)*x80*x98))+x145+(((-1.0)*x105*x95))+(((-1.0)*x100*x94))+(((-1.0)*x100*x77))+((x103*x77)));
op[3]=((((-1.0)*x147))+(((-1.0)*x95*x99))+(((-0.1648656)*gconst2*x102))+(((-0.3297312)*gconst5*x102))+x146+(((-0.1648656)*gconst1*x102))+(((-0.3297312)*gconst6*x102))+((x94*x99))+((x77*x99))+(((-1.0)*x85*x99)));
op[4]=((((-1.0)*x144))+(((-1.0)*x143))+((x100*x92))+((x100*x91))+((x100*x87))+((x100*x88))+(((-1.0)*x103*x87))+((x103*x83))+((x103*x82))+((x101*x89))+(((-0.13189248)*x117))+(((-1.0)*x105*x87))+x141+x142+(((-1.0)*x105*x91))+(((-1.0)*gconst7*x73*x86))+(((-1.0)*gconst3*x73*x89))+(((-1.0)*x100*x83))+(((-1.0)*x100*x82))+(((-1.0)*x101*x80))+(((-1.0)*x100*x93))+(((-1.0)*x100*x90))+((gconst3*x73*x80)));
op[5]=((((-1.0)*x146))+(((-0.3297312)*gconst2*x102))+((x79*x99))+((x78*x99))+x147+(((-0.1648656)*gconst5*x102))+(((-0.1648656)*gconst6*x102))+(((-1.0)*x84*x99))+(((-0.3297312)*gconst1*x102))+(((-1.0)*x96*x99)));
op[6]=((((-1.0)*x148))+(((-1.0)*x105*x79))+((x103*x84))+((x101*x86))+((x100*x78))+((x100*x79))+x145+(((-1.0)*x100*x84))+(((-1.0)*x100*x96))+(((-1.0)*x103*x78))+(((-1.0)*x103*x79)));
op[7]=((((-1.0)*x113))+x136+(((-1.0)*x137))+x97);
op[8]=((((-1.0)*x143))+x141);
polyroots8(op,zeror,numroots);
IkReal j27array[8], cj27array[8], sj27array[8], tempj27array[1];
int numsolutions = 0;
for(int ij27 = 0; ij27 < numroots; ++ij27)
{
IkReal htj27 = zeror[ij27];
tempj27array[0]=((2.0)*(atan(htj27)));
for(int kj27 = 0; kj27 < 1; ++kj27)
{
j27array[numsolutions] = tempj27array[kj27];
if( j27array[numsolutions] > IKPI )
{
    j27array[numsolutions]-=IK2PI;
}
else if( j27array[numsolutions] < -IKPI )
{
    j27array[numsolutions]+=IK2PI;
}
sj27array[numsolutions] = IKsin(j27array[numsolutions]);
cj27array[numsolutions] = IKcos(j27array[numsolutions]);
numsolutions++;
}
}
bool j27valid[8]={true,true,true,true,true,true,true,true};
_nj27 = 8;
for(int ij27 = 0; ij27 < numsolutions; ++ij27)
    {
if( !j27valid[ij27] )
{
    continue;
}
    j27 = j27array[ij27]; cj27 = cj27array[ij27]; sj27 = sj27array[ij27];
htj27 = IKtan(j27/2);

_ij27[0] = ij27; _ij27[1] = -1;
for(int iij27 = ij27+1; iij27 < numsolutions; ++iij27)
{
if( j27valid[iij27] && IKabs(cj27array[ij27]-cj27array[iij27]) < IKFAST_SOLUTION_THRESH && IKabs(sj27array[ij27]-sj27array[iij27]) < IKFAST_SOLUTION_THRESH )
{
    j27valid[iij27]=false; _ij27[1] = iij27; break; 
}
}
{
IkReal j28eval[2];
IkReal x149=cj27*cj27;
IkReal x150=py*py;
IkReal x151=px*px;
IkReal x152=pz*pz;
IkReal x153=((100.0)*sj29);
IkReal x154=(py*sj27);
IkReal x155=((4.0)*sj29);
IkReal x156=(cj27*px*sj29);
IkReal x157=(x149*x151);
IkReal x158=(x150*x155);
j28eval[0]=((((20.0)*x156))+(((-1.0)*x153*x157))+(((-1.0)*x150*x153))+(((-1.0)*sj29))+(((-1.0)*x152*x153))+((x149*x150*x153))+(((-200.0)*x154*x156))+(((20.0)*sj29*x154)));
j28eval[1]=IKsign((((x149*x158))+(((-1.0)*x158))+(((0.8)*sj29*x154))+(((-1.0)*x152*x155))+(((-0.04)*sj29))+(((0.8)*x156))+(((-1.0)*x155*x157))+(((-8.0)*x154*x156))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  )
{
{
IkReal j30eval[1];
j30eval[0]=sj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[3];
bool bgotonextstatement = true;
do
{
IkReal x159=((((-1.0)*cj27*py))+((px*sj27)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
evalcond[1]=x159;
evalcond[2]=x159;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[2], cj30array[2], sj30array[2];
bool j30valid[2]={false};
_nj30 = 2;
cj30array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)));
if( cj30array[0] >= -1-IKFAST_SINCOS_THRESH && cj30array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j30valid[0] = j30valid[1] = true;
    j30array[0] = IKacos(cj30array[0]);
    sj30array[0] = IKsin(j30array[0]);
    cj30array[1] = cj30array[0];
    j30array[1] = -j30array[0];
    sj30array[1] = -sj30array[0];
}
else if( isnan(cj30array[0]) )
{
    // probably any value will work
    j30valid[0] = true;
    cj30array[0] = 1; sj30array[0] = 0; j30array[0] = 0;
}
for(int ij30 = 0; ij30 < 2; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 2; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];

{
IkReal j28eval[3];
sj29=0;
cj29=1.0;
j29=0;
IkReal x160=((321000.0)*cj30);
IkReal x161=(py*sj27);
IkReal x162=((321000.0)*sj30);
IkReal x163=(cj27*px);
j28eval[0]=((1.02430295950156)+cj30);
j28eval[1]=((IKabs(((-40000.0)+(((400000.0)*x161))+(((400000.0)*x163))+(((-32100.0)*cj30))+(((-1.0)*pz*x162))+((x160*x161))+((x160*x163)))))+(IKabs(((((32100.0)*sj30))+(((-1.0)*x161*x162))+(((-1.0)*pz*x160))+(((-1.0)*x162*x163))+(((-400000.0)*pz))))));
j28eval[2]=IKsign(((263041.0)+(((256800.0)*cj30))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
{
IkReal j28eval[3];
sj29=0;
cj29=1.0;
j29=0;
IkReal x164=(pz*sj30);
IkReal x165=(cj27*px);
IkReal x166=(py*sj27);
IkReal x167=((10.0)*cj30);
IkReal x168=((321.0)*cj30);
IkReal x169=((1000.0)*pz);
j28eval[0]=((1.24610591900312)+(((-1.0)*x166*x167))+cj30+(((-1.0)*x165*x167))+(((-10.0)*x164))+(((-12.4610591900312)*x165))+(((-12.4610591900312)*x166)));
j28eval[1]=((IKabs(((((-100.0)*pz))+(((128.4)*sj30))+((x166*x169))+((x165*x169))+(((103.041)*cj30*sj30)))))+(IKabs(((-160.0)+((pz*x169))+(((-103.041)*(cj30*cj30)))+(((-256.8)*cj30))))));
j28eval[2]=IKsign(((40.0)+(((-1.0)*x166*x168))+(((-400.0)*x165))+(((-400.0)*x166))+(((-321.0)*x164))+(((32.1)*cj30))+(((-1.0)*x165*x168))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
{
IkReal j28eval[3];
sj29=0;
cj29=1.0;
j29=0;
IkReal x170=cj27*cj27;
IkReal x171=py*py;
IkReal x172=pz*pz;
IkReal x173=px*px;
IkReal x174=(cj27*px);
IkReal x175=((321.0)*sj30);
IkReal x176=(py*sj27);
IkReal x177=((321.0)*cj30);
IkReal x178=((321.0)*x176);
IkReal x179=((200.0)*x176);
IkReal x180=(x170*x171);
IkReal x181=(x170*x173);
j28eval[0]=((-1.0)+(((-1.0)*x174*x179))+(((-100.0)*x172))+(((-100.0)*x171))+(((-100.0)*x181))+(((20.0)*x176))+(((20.0)*x174))+(((100.0)*x180)));
j28eval[1]=((IKabs((((pz*x177))+(((400.0)*pz))+((x175*x176))+((x174*x175))+(((-32.1)*sj30)))))+(IKabs(((40.0)+((pz*x175))+(((-1.0)*x174*x177))+(((-400.0)*x174))+(((-400.0)*x176))+(((-1.0)*x176*x177))+(((32.1)*cj30))))));
j28eval[2]=IKsign(((-10.0)+x179+(((-1000.0)*x181))+(((-2000.0)*x174*x176))+(((-1000.0)*x171))+(((-1000.0)*x172))+(((200.0)*x174))+(((1000.0)*x180))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j28]

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x182=py*py;
IkReal x183=cj27*cj27;
IkReal x184=(cj27*px);
IkReal x185=(py*sj27);
IkReal x186=((321.0)*cj30);
IkReal x187=((321.0)*sj30);
IkReal x188=((1000.0)*x183);
CheckValue<IkReal> x189=IKPowWithIntegerCheck(IKsign(((-10.0)+(((-1.0)*x188*(px*px)))+(((-2000.0)*x184*x185))+(((-1000.0)*(pz*pz)))+(((-1000.0)*x182))+(((200.0)*x185))+(((200.0)*x184))+((x182*x188)))),-1);
if(!x189.valid){
continue;
}
CheckValue<IkReal> x190 = IKatan2WithCheck(IkReal((((pz*x186))+(((400.0)*pz))+((x185*x187))+((x184*x187))+(((-32.1)*sj30)))),((40.0)+((pz*x187))+(((-400.0)*x185))+(((-400.0)*x184))+(((-1.0)*x184*x186))+(((-1.0)*x185*x186))+(((32.1)*cj30))),IKFAST_ATAN2_MAGTHRESH);
if(!x190.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x189.value)))+(x190.value));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x191=IKsin(j28);
IkReal x192=IKcos(j28);
IkReal x193=((0.321)*cj30);
IkReal x194=((0.321)*sj30);
IkReal x195=(cj27*px);
IkReal x196=(py*sj27);
IkReal x197=((1.0)*x196);
IkReal x198=(pz*x191);
IkReal x199=((0.8)*x192);
evalcond[0]=((((0.4)*x191))+((x192*x194))+pz+((x191*x193)));
evalcond[1]=(x194+((x191*x196))+((x191*x195))+(((-0.1)*x191))+((pz*x192)));
evalcond[2]=((0.1)+(((0.4)*x192))+(((-1.0)*x191*x194))+(((-1.0)*x195))+(((-1.0)*x197))+((x192*x193)));
evalcond[3]=((0.4)+(((-1.0)*x192*x197))+(((0.1)*x192))+x198+x193+(((-1.0)*x192*x195)));
evalcond[4]=((-0.066959)+(((0.2)*x196))+(((0.2)*x195))+((x196*x199))+(((-1.0)*pp))+((x195*x199))+(((-0.08)*x192))+(((-0.8)*x198)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x651=((321.0)*cj30);
IkReal x652=(py*sj27);
IkReal x653=(cj27*px);
IkReal x654=((1000.0)*pz);
CheckValue<IkReal> x655 = IKatan2WithCheck(IkReal(((((-100.0)*pz))+((x652*x654))+((x653*x654))+(((128.4)*sj30))+(((103.041)*cj30*sj30)))),((-160.0)+((pz*x654))+(((-103.041)*(cj30*cj30)))+(((-256.8)*cj30))),IKFAST_ATAN2_MAGTHRESH);
if(!x655.valid){
continue;
}
CheckValue<IkReal> x656=IKPowWithIntegerCheck(IKsign(((40.0)+(((-1.0)*x651*x653))+(((-1.0)*x651*x652))+(((-321.0)*pz*sj30))+(((-400.0)*x653))+(((-400.0)*x652))+(((32.1)*cj30)))),-1);
if(!x656.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(x655.value)+(((1.5707963267949)*(x656.value))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x657=IKsin(j28);
IkReal x658=IKcos(j28);
IkReal x659=((0.321)*cj30);
IkReal x660=((0.321)*sj30);
IkReal x661=(cj27*px);
IkReal x662=(py*sj27);
IkReal x663=((1.0)*x662);
IkReal x664=(pz*x657);
IkReal x665=((0.8)*x658);
evalcond[0]=((((0.4)*x657))+pz+((x657*x659))+((x658*x660)));
evalcond[1]=((((-0.1)*x657))+((x657*x662))+((x657*x661))+((pz*x658))+x660);
evalcond[2]=((0.1)+(((-1.0)*x657*x660))+(((-1.0)*x661))+(((-1.0)*x663))+(((0.4)*x658))+((x658*x659)));
evalcond[3]=((0.4)+(((-1.0)*x658*x663))+x659+x664+(((0.1)*x658))+(((-1.0)*x658*x661)));
evalcond[4]=((-0.066959)+((x662*x665))+(((-0.8)*x664))+(((-1.0)*pp))+((x661*x665))+(((0.2)*x662))+(((0.2)*x661))+(((-0.08)*x658)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x666=((321000.0)*cj30);
IkReal x667=(py*sj27);
IkReal x668=(cj27*px);
IkReal x669=((321000.0)*sj30);
CheckValue<IkReal> x670=IKPowWithIntegerCheck(IKsign(((263041.0)+(((256800.0)*cj30)))),-1);
if(!x670.valid){
continue;
}
CheckValue<IkReal> x671 = IKatan2WithCheck(IkReal(((((32100.0)*sj30))+(((-1.0)*x668*x669))+(((-400000.0)*pz))+(((-1.0)*pz*x666))+(((-1.0)*x667*x669)))),((-40000.0)+((x666*x668))+((x666*x667))+(((-32100.0)*cj30))+(((400000.0)*x668))+(((400000.0)*x667))+(((-1.0)*pz*x669))),IKFAST_ATAN2_MAGTHRESH);
if(!x671.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x670.value)))+(x671.value));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x672=IKsin(j28);
IkReal x673=IKcos(j28);
IkReal x674=((0.321)*cj30);
IkReal x675=((0.321)*sj30);
IkReal x676=(cj27*px);
IkReal x677=(py*sj27);
IkReal x678=((1.0)*x677);
IkReal x679=(pz*x672);
IkReal x680=((0.8)*x673);
evalcond[0]=(((x673*x675))+((x672*x674))+(((0.4)*x672))+pz);
evalcond[1]=(((pz*x673))+((x672*x676))+((x672*x677))+(((-0.1)*x672))+x675);
evalcond[2]=((0.1)+((x673*x674))+(((0.4)*x673))+(((-1.0)*x676))+(((-1.0)*x672*x675))+(((-1.0)*x678)));
evalcond[3]=((0.4)+(((0.1)*x673))+x679+x674+(((-1.0)*x673*x676))+(((-1.0)*x673*x678)));
evalcond[4]=((-0.066959)+(((-0.08)*x673))+(((0.2)*x676))+(((0.2)*x677))+((x677*x680))+((x676*x680))+(((-1.0)*pp))+(((-0.8)*x679)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x681=(px*sj27);
IkReal x682=(cj27*py);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
evalcond[1]=(x681+(((-1.0)*x682)));
evalcond[2]=(x682+(((-1.0)*x681)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[2], cj30array[2], sj30array[2];
bool j30valid[2]={false};
_nj30 = 2;
cj30array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)));
if( cj30array[0] >= -1-IKFAST_SINCOS_THRESH && cj30array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j30valid[0] = j30valid[1] = true;
    j30array[0] = IKacos(cj30array[0]);
    sj30array[0] = IKsin(j30array[0]);
    cj30array[1] = cj30array[0];
    j30array[1] = -j30array[0];
    sj30array[1] = -sj30array[0];
}
else if( isnan(cj30array[0]) )
{
    // probably any value will work
    j30valid[0] = true;
    cj30array[0] = 1; sj30array[0] = 0; j30array[0] = 0;
}
for(int ij30 = 0; ij30 < 2; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 2; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];

{
IkReal j28eval[3];
sj29=0;
cj29=-1.0;
j29=3.14159265358979;
IkReal x683=((321000.0)*cj30);
IkReal x684=(py*sj27);
IkReal x685=((321000.0)*sj30);
IkReal x686=(cj27*px);
j28eval[0]=((-1.02430295950156)+(((-1.0)*cj30)));
j28eval[1]=IKsign(((-263041.0)+(((-256800.0)*cj30))));
j28eval[2]=((IKabs(((((-1.0)*x685*x686))+(((32100.0)*sj30))+(((400000.0)*pz))+(((-1.0)*x684*x685))+((pz*x683)))))+(IKabs(((40000.0)+(((-400000.0)*x686))+(((-400000.0)*x684))+(((32100.0)*cj30))+(((-1.0)*x683*x686))+(((-1.0)*x683*x684))+(((-1.0)*pz*x685))))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
{
IkReal j28eval[3];
sj29=0;
cj29=-1.0;
j29=3.14159265358979;
IkReal x687=(pz*sj30);
IkReal x688=(cj27*px);
IkReal x689=(py*sj27);
IkReal x690=((10.0)*cj30);
IkReal x691=((1000.0)*pz);
IkReal x692=((321.0)*cj30);
j28eval[0]=((-1.24610591900312)+((x688*x690))+((x689*x690))+(((-1.0)*cj30))+(((-10.0)*x687))+(((12.4610591900312)*x688))+(((12.4610591900312)*x689)));
j28eval[1]=((IKabs(((160.0)+(((-1.0)*pz*x691))+(((103.041)*(cj30*cj30)))+(((256.8)*cj30)))))+(IKabs(((((100.0)*pz))+(((128.4)*sj30))+(((-1.0)*x688*x691))+(((-1.0)*x689*x691))+(((103.041)*cj30*sj30))))));
j28eval[2]=IKsign(((-40.0)+((x688*x692))+((x689*x692))+(((400.0)*x689))+(((400.0)*x688))+(((-321.0)*x687))+(((-32.1)*cj30))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
{
IkReal j28eval[3];
sj29=0;
cj29=-1.0;
j29=3.14159265358979;
IkReal x693=cj27*cj27;
IkReal x694=py*py;
IkReal x695=pz*pz;
IkReal x696=px*px;
IkReal x697=(cj27*px);
IkReal x698=((321.0)*sj30);
IkReal x699=(py*sj27);
IkReal x700=((321.0)*cj30);
IkReal x701=((321.0)*x699);
IkReal x702=((200.0)*x699);
IkReal x703=(x693*x694);
IkReal x704=(x693*x696);
j28eval[0]=((-1.0)+(((20.0)*x697))+(((20.0)*x699))+(((-100.0)*x704))+(((-100.0)*x695))+(((-100.0)*x694))+(((-1.0)*x697*x702))+(((100.0)*x703)));
j28eval[1]=((IKabs(((((-1.0)*x697*x698))+(((400.0)*pz))+(((32.1)*sj30))+(((-1.0)*x698*x699))+((pz*x700)))))+(IKabs(((40.0)+(((-400.0)*x699))+(((-400.0)*x697))+(((-1.0)*x699*x700))+(((-1.0)*pz*x698))+(((-1.0)*x697*x700))+(((32.1)*cj30))))));
j28eval[2]=IKsign(((-10.0)+(((1000.0)*x703))+(((-1000.0)*x695))+(((-1000.0)*x694))+(((-2000.0)*x697*x699))+(((-1000.0)*x704))+(((200.0)*x697))+x702));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j28]

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x705=py*py;
IkReal x706=cj27*cj27;
IkReal x707=(cj27*px);
IkReal x708=(py*sj27);
IkReal x709=((321.0)*cj30);
IkReal x710=((321.0)*sj30);
IkReal x711=((1000.0)*x706);
CheckValue<IkReal> x712=IKPowWithIntegerCheck(IKsign(((-10.0)+(((-1000.0)*(pz*pz)))+(((-1.0)*x711*(px*px)))+(((-1000.0)*x705))+(((-2000.0)*x707*x708))+(((200.0)*x707))+(((200.0)*x708))+((x705*x711)))),-1);
if(!x712.valid){
continue;
}
CheckValue<IkReal> x713 = IKatan2WithCheck(IkReal(((((-1.0)*x707*x710))+(((400.0)*pz))+(((32.1)*sj30))+(((-1.0)*x708*x710))+((pz*x709)))),((40.0)+(((-1.0)*pz*x710))+(((-1.0)*x707*x709))+(((-400.0)*x708))+(((-400.0)*x707))+(((-1.0)*x708*x709))+(((32.1)*cj30))),IKFAST_ATAN2_MAGTHRESH);
if(!x713.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x712.value)))+(x713.value));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x714=IKsin(j28);
IkReal x715=IKcos(j28);
IkReal x716=((0.321)*cj30);
IkReal x717=((0.321)*sj30);
IkReal x718=(py*sj27);
IkReal x719=(cj27*px);
IkReal x720=((1.0)*x718);
IkReal x721=(pz*x714);
IkReal x722=((1.0)*x715);
IkReal x723=((0.8)*x715);
evalcond[0]=(((x714*x716))+(((0.4)*x714))+pz+(((-1.0)*x715*x717)));
evalcond[1]=((0.1)+((x715*x716))+((x714*x717))+(((0.4)*x715))+(((-1.0)*x719))+(((-1.0)*x720)));
evalcond[2]=((0.4)+(((0.1)*x715))+x716+x721+(((-1.0)*x715*x720))+(((-1.0)*x719*x722)));
evalcond[3]=((((0.1)*x714))+(((-1.0)*x714*x719))+x717+(((-1.0)*x714*x720))+(((-1.0)*pz*x722)));
evalcond[4]=((-0.066959)+(((-1.0)*pp))+(((-0.8)*x721))+((x718*x723))+((x719*x723))+(((0.2)*x719))+(((0.2)*x718))+(((-0.08)*x715)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x724=((321.0)*cj30);
IkReal x725=(py*sj27);
IkReal x726=(cj27*px);
IkReal x727=((1000.0)*pz);
CheckValue<IkReal> x728 = IKatan2WithCheck(IkReal(((((100.0)*pz))+(((128.4)*sj30))+(((-1.0)*x725*x727))+(((-1.0)*x726*x727))+(((103.041)*cj30*sj30)))),((160.0)+(((103.041)*(cj30*cj30)))+(((256.8)*cj30))+(((-1.0)*pz*x727))),IKFAST_ATAN2_MAGTHRESH);
if(!x728.valid){
continue;
}
CheckValue<IkReal> x729=IKPowWithIntegerCheck(IKsign(((-40.0)+(((400.0)*x725))+(((400.0)*x726))+(((-321.0)*pz*sj30))+((x724*x726))+((x724*x725))+(((-32.1)*cj30)))),-1);
if(!x729.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(x728.value)+(((1.5707963267949)*(x729.value))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x730=IKsin(j28);
IkReal x731=IKcos(j28);
IkReal x732=((0.321)*cj30);
IkReal x733=((0.321)*sj30);
IkReal x734=(py*sj27);
IkReal x735=(cj27*px);
IkReal x736=((1.0)*x734);
IkReal x737=(pz*x730);
IkReal x738=((1.0)*x731);
IkReal x739=((0.8)*x731);
evalcond[0]=((((0.4)*x730))+(((-1.0)*x731*x733))+pz+((x730*x732)));
evalcond[1]=((0.1)+(((0.4)*x731))+((x731*x732))+(((-1.0)*x735))+(((-1.0)*x736))+((x730*x733)));
evalcond[2]=((0.4)+(((-1.0)*x731*x736))+(((-1.0)*x735*x738))+(((0.1)*x731))+x737+x732);
evalcond[3]=((((-1.0)*x730*x735))+(((-1.0)*x730*x736))+(((0.1)*x730))+x733+(((-1.0)*pz*x738)));
evalcond[4]=((-0.066959)+(((-0.08)*x731))+((x735*x739))+((x734*x739))+(((-1.0)*pp))+(((-0.8)*x737))+(((0.2)*x735))+(((0.2)*x734)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x740=(cj27*px);
IkReal x741=((321000.0)*cj30);
IkReal x742=((321000.0)*sj30);
IkReal x743=((321000.0)*py*sj27);
CheckValue<IkReal> x744=IKPowWithIntegerCheck(IKsign(((-263041.0)+(((-256800.0)*cj30)))),-1);
if(!x744.valid){
continue;
}
CheckValue<IkReal> x745 = IKatan2WithCheck(IkReal(((((-1.0)*py*sj27*x742))+(((32100.0)*sj30))+(((400000.0)*pz))+(((-1.0)*x740*x742))+((pz*x741)))),((40000.0)+(((-1.0)*py*sj27*x741))+(((-400000.0)*py*sj27))+(((-400000.0)*x740))+(((-1.0)*pz*x742))+(((32100.0)*cj30))+(((-1.0)*x740*x741))),IKFAST_ATAN2_MAGTHRESH);
if(!x745.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x744.value)))+(x745.value));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x746=IKsin(j28);
IkReal x747=IKcos(j28);
IkReal x748=((0.321)*cj30);
IkReal x749=((0.321)*sj30);
IkReal x750=(py*sj27);
IkReal x751=(cj27*px);
IkReal x752=((1.0)*x750);
IkReal x753=(pz*x746);
IkReal x754=((1.0)*x747);
IkReal x755=((0.8)*x747);
evalcond[0]=((((-1.0)*x747*x749))+((x746*x748))+pz+(((0.4)*x746)));
evalcond[1]=((0.1)+((x747*x748))+((x746*x749))+(((-1.0)*x751))+(((0.4)*x747))+(((-1.0)*x752)));
evalcond[2]=((0.4)+(((0.1)*x747))+(((-1.0)*x751*x754))+(((-1.0)*x747*x752))+x753+x748);
evalcond[3]=((((0.1)*x746))+(((-1.0)*x746*x752))+(((-1.0)*x746*x751))+x749+(((-1.0)*pz*x754)));
evalcond[4]=((-0.066959)+((x751*x755))+(((-0.08)*x747))+(((0.2)*x751))+(((0.2)*x750))+(((-1.0)*pp))+(((-0.8)*x753))+((x750*x755)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j28, j30]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x756=IKPowWithIntegerCheck(sj29,-1);
if(!x756.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x756.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x756.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x756.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[2];
evalcond[0]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*sj29*(IKsin(j30)))));
evalcond[1]=((0.253041)+(((0.2568)*(IKcos(j30))))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j28eval[3];
IkReal x757=(py*sj27);
IkReal x758=(cj29*sj30);
IkReal x759=(cj27*px);
IkReal x760=((10.0)*cj30);
IkReal x761=((1000.0)*pz);
IkReal x762=((321.0)*cj30);
j28eval[0]=((-1.24610591900312)+((x757*x760))+(((10.0)*pz*x758))+((x759*x760))+(((-1.0)*cj30))+(((12.4610591900312)*x759))+(((12.4610591900312)*x757)));
j28eval[1]=IKsign(((-40.0)+((x757*x762))+((x759*x762))+(((400.0)*x757))+(((400.0)*x759))+(((321.0)*pz*x758))+(((-32.1)*cj30))));
j28eval[2]=((IKabs(((((100.0)*pz))+(((-1.0)*x757*x761))+(((-128.4)*x758))+(((-103.041)*cj30*x758))+(((-1.0)*x759*x761)))))+(IKabs(((160.0)+(((103.041)*(cj30*cj30)))+(((256.8)*cj30))+(((-1.0)*pz*x761))))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
{
IkReal j28eval[3];
IkReal x763=cj29*cj29;
IkReal x764=cj30*cj30;
IkReal x765=(cj27*px);
IkReal x766=((321000.0)*cj30);
IkReal x767=(py*sj27);
IkReal x768=((321000.0)*cj29*sj30);
IkReal x769=((103041.0)*x764);
j28eval[0]=((1.5527799613746)+(((-1.0)*x763*x764))+x764+x763+(((2.49221183800623)*cj30)));
j28eval[1]=IKsign(((160000.0)+(((-1.0)*x763*x769))+(((256800.0)*cj30))+(((103041.0)*x763))+x769));
j28eval[2]=((IKabs(((((-1.0)*x765*x768))+(((32100.0)*cj29*sj30))+(((-1.0)*x767*x768))+(((-400000.0)*pz))+(((-1.0)*pz*x766)))))+(IKabs(((-40000.0)+(((-32100.0)*cj30))+((x765*x766))+(((400000.0)*x767))+(((400000.0)*x765))+((x766*x767))+(((-1.0)*pz*x768))))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
{
IkReal j28eval[2];
IkReal x770=(cj29*sj30);
IkReal x771=(py*sj27);
IkReal x772=(cj30*pz);
IkReal x773=(cj27*px);
j28eval[0]=((((-10.0)*x770*x771))+(((-10.0)*x770*x773))+x770+(((10.0)*x772))+(((12.4610591900312)*pz)));
j28eval[1]=IKsign(((((400.0)*pz))+(((32.1)*x770))+(((-321.0)*x770*x773))+(((-321.0)*x770*x771))+(((321.0)*x772))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x774=((((0.321)*sj30))+(((-1.0)*cj27*py))+((px*sj27)));
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j29), 6.28318530717959))))));
evalcond[1]=x774;
evalcond[2]=((0.253041)+(((0.2568)*cj30))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
evalcond[3]=x774;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28eval[1];
IkReal x775=((-1.0)*py);
pz=0;
j29=1.5707963267949;
sj29=1.0;
cj29=0;
pp=((px*px)+(py*py));
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x775);
rxp0_1=(px*r20);
rxp1_0=(r21*x775);
rxp1_1=(px*r21);
rxp2_0=(r22*x775);
rxp2_1=(px*r22);
j28eval[0]=((1.0)+(((-10.0)*cj27*px))+(((-10.0)*py*sj27)));
if( IKabs(j28eval[0]) < 0.0000010000000000  )
{
{
IkReal j28eval[1];
IkReal x776=((-1.0)*py);
pz=0;
j29=1.5707963267949;
sj29=1.0;
cj29=0;
pp=((px*px)+(py*py));
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x776);
rxp0_1=(px*r20);
rxp1_0=(r21*x776);
rxp1_1=(px*r21);
rxp2_0=(r22*x776);
rxp2_1=(px*r22);
j28eval[0]=((1.24610591900312)+cj30);
if( IKabs(j28eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x777=((((100.0)*(px*px)))+(((100.0)*(py*py))));
if((x777) < -0.00001)
continue;
IkReal x778=IKabs(IKsqrt(x777));
IkReal x784 = x777;
if(IKabs(x784)==0){
continue;
}
IkReal x779=pow(x784,-0.5);
CheckValue<IkReal> x785=IKPowWithIntegerCheck(x778,-1);
if(!x785.valid){
continue;
}
IkReal x780=x785.value;
IkReal x781=((10.0)*px*x779);
IkReal x782=((10.0)*py*x779);
if((((1.0)+(((-1.0)*(x780*x780))))) < -0.00001)
continue;
IkReal x783=IKsqrt(((1.0)+(((-1.0)*(x780*x780)))));
CheckValue<IkReal> x786 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x786.valid){
continue;
}
if( (x780) < -1-IKFAST_SINCOS_THRESH || (x780) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal gconst24=((((-1.0)*(x786.value)))+(((-1.0)*(IKasin(x780)))));
IkReal gconst25=(((x781*x783))+((x780*x782)));
IkReal gconst26=((((-1.0)*x782*x783))+((x780*x781)));
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x787=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x787.valid){
continue;
}
if( (x787.value) < -1-IKFAST_SINCOS_THRESH || (x787.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x788 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x788.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((IKasin(x787.value))+j27+(x788.value))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x790=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst25*py))+(((-1.0)*gconst26*px))),-1);
if(!x790.valid){
continue;
}
IkReal x789=x790.value;
cj28array[0]=((((-0.321)*cj30*x789))+(((-0.4)*x789)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x791=IKsin(j28);
IkReal x792=IKcos(j28);
IkReal x793=(gconst25*py);
IkReal x794=(gconst26*px);
IkReal x795=((0.321)*cj30);
IkReal x796=((1.0)*x791);
IkReal x797=((0.8)*x792);
evalcond[0]=((((0.4)*x791))+((x791*x795)));
evalcond[1]=((((-1.0)*x794*x796))+(((-1.0)*x793*x796))+(((0.1)*x791)));
evalcond[2]=((0.1)+((x792*x795))+(((-1.0)*x794))+(((-1.0)*x793))+(((0.4)*x792)));
evalcond[3]=((-0.32)+((x793*x797))+(((-0.08)*x792))+(((-0.2568)*cj30))+((x794*x797)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x798=((((100.0)*(px*px)))+(((100.0)*(py*py))));
IkReal x805 = x798;
if(IKabs(x805)==0){
continue;
}
IkReal x799=pow(x805,-0.5);
if((x798) < -0.00001)
continue;
IkReal x800=IKabs(IKsqrt(x798));
CheckValue<IkReal> x806=IKPowWithIntegerCheck(x800,-1);
if(!x806.valid){
continue;
}
IkReal x801=x806.value;
IkReal x802=((10.0)*px*x799);
IkReal x803=((10.0)*py*x799);
if((((1.0)+(((-1.0)*(x801*x801))))) < -0.00001)
continue;
IkReal x804=IKsqrt(((1.0)+(((-1.0)*(x801*x801)))));
CheckValue<IkReal> x807 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x807.valid){
continue;
}
if( (x801) < -1-IKFAST_SINCOS_THRESH || (x801) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal gconst27=((3.14159265358979)+(((-1.0)*(x807.value)))+(IKasin(x801)));
IkReal gconst28=(((x801*x803))+(((-1.0)*x802*x804)));
IkReal gconst29=(((x803*x804))+((x801*x802)));
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x808=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x808.valid){
continue;
}
if( (x808.value) < -1-IKFAST_SINCOS_THRESH || (x808.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x809 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x809.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(((-1.0)*(IKasin(x808.value))))+j27+(x809.value))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x811=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst29*px))+(((-1.0)*gconst28*py))),-1);
if(!x811.valid){
continue;
}
IkReal x810=x811.value;
cj28array[0]=((((-0.4)*x810))+(((-0.321)*cj30*x810)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x812=IKsin(j28);
IkReal x813=IKcos(j28);
IkReal x814=(gconst28*py);
IkReal x815=((0.321)*cj30);
IkReal x816=((0.8)*x813);
IkReal x817=((1.0)*gconst29*px);
evalcond[0]=(((x812*x815))+(((0.4)*x812)));
evalcond[1]=((((-1.0)*x812*x817))+(((-1.0)*x812*x814))+(((0.1)*x812)));
evalcond[2]=((0.1)+(((-1.0)*x817))+((x813*x815))+(((0.4)*x813))+(((-1.0)*x814)));
evalcond[3]=((-0.32)+((x814*x816))+((gconst29*px*x816))+(((-0.2568)*cj30))+(((-0.08)*x813)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j28]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x819=IKPowWithIntegerCheck(((0.4)+(((0.321)*cj30))),-1);
if(!x819.valid){
continue;
}
IkReal x818=x819.value;
cj28array[0]=(((py*sj27*x818))+((cj27*px*x818))+(((-0.1)*x818)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x820=IKsin(j28);
IkReal x821=IKcos(j28);
IkReal x822=((0.321)*cj30);
IkReal x823=(cj27*px);
IkReal x824=((1.0)*x820);
IkReal x825=(py*sj27*x821);
evalcond[0]=(((x820*x822))+(((0.4)*x820)));
evalcond[1]=((((0.1)*x820))+(((-1.0)*x823*x824))+(((-1.0)*py*sj27*x824)));
evalcond[2]=((0.4)+(((0.1)*x821))+(((-1.0)*x825))+(((-1.0)*x821*x823))+x822);
evalcond[3]=((-0.32)+(((0.8)*x825))+(((-0.08)*x821))+(((0.8)*x821*x823))+(((-0.2568)*cj30)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x827=IKPowWithIntegerCheck(((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))),-1);
if(!x827.valid){
continue;
}
IkReal x826=x827.value;
cj28array[0]=((((-0.4)*x826))+(((-0.321)*cj30*x826)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x828=IKsin(j28);
IkReal x829=IKcos(j28);
IkReal x830=(py*sj27);
IkReal x831=(cj27*px);
IkReal x832=((0.321)*cj30);
IkReal x833=((0.8)*x829);
IkReal x834=((1.0)*x828);
evalcond[0]=((((0.4)*x828))+((x828*x832)));
evalcond[1]=((((0.1)*x828))+(((-1.0)*x830*x834))+(((-1.0)*x831*x834)));
evalcond[2]=((0.1)+(((0.4)*x829))+((x829*x832))+(((-1.0)*x831))+(((-1.0)*x830)));
evalcond[3]=((-0.32)+((x831*x833))+(((-0.08)*x829))+(((-0.2568)*cj30))+((x830*x833)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x835=((0.321)*sj30);
IkReal x836=(cj27*py);
IkReal x837=(px*sj27);
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j29), 6.28318530717959))))));
evalcond[1]=((((-1.0)*x835))+(((-1.0)*x836))+x837);
evalcond[2]=((0.253041)+(((0.2568)*cj30))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
evalcond[3]=((((-1.0)*x837))+x835+x836);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28eval[1];
IkReal x838=((-1.0)*py);
pz=0;
j29=-1.5707963267949;
sj29=-1.0;
cj29=0;
pp=((px*px)+(py*py));
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x838);
rxp0_1=(px*r20);
rxp1_0=(r21*x838);
rxp1_1=(px*r21);
rxp2_0=(r22*x838);
rxp2_1=(px*r22);
j28eval[0]=((1.0)+(((-10.0)*cj27*px))+(((-10.0)*py*sj27)));
if( IKabs(j28eval[0]) < 0.0000010000000000  )
{
{
IkReal j28eval[1];
IkReal x839=((-1.0)*py);
pz=0;
j29=-1.5707963267949;
sj29=-1.0;
cj29=0;
pp=((px*px)+(py*py));
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x839);
rxp0_1=(px*r20);
rxp1_0=(r21*x839);
rxp1_1=(px*r21);
rxp2_0=(r22*x839);
rxp2_1=(px*r22);
j28eval[0]=((1.24610591900312)+cj30);
if( IKabs(j28eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x840=((((100.0)*(px*px)))+(((100.0)*(py*py))));
if((x840) < -0.00001)
continue;
IkReal x841=IKabs(IKsqrt(x840));
IkReal x847 = x840;
if(IKabs(x847)==0){
continue;
}
IkReal x842=pow(x847,-0.5);
CheckValue<IkReal> x848=IKPowWithIntegerCheck(x841,-1);
if(!x848.valid){
continue;
}
IkReal x843=x848.value;
IkReal x844=((10.0)*px*x842);
IkReal x845=((10.0)*py*x842);
if((((1.0)+(((-1.0)*(x843*x843))))) < -0.00001)
continue;
IkReal x846=IKsqrt(((1.0)+(((-1.0)*(x843*x843)))));
CheckValue<IkReal> x849 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x849.valid){
continue;
}
if( (x843) < -1-IKFAST_SINCOS_THRESH || (x843) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal gconst30=((((-1.0)*(x849.value)))+(((-1.0)*(IKasin(x843)))));
IkReal gconst31=(((x843*x845))+((x844*x846)));
IkReal gconst32=(((x843*x844))+(((-1.0)*x845*x846)));
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x850=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x850.valid){
continue;
}
if( (x850.value) < -1-IKFAST_SINCOS_THRESH || (x850.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x851 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x851.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((IKasin(x850.value))+j27+(x851.value))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x853=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst32*px))+(((-1.0)*gconst31*py))),-1);
if(!x853.valid){
continue;
}
IkReal x852=x853.value;
cj28array[0]=((((-0.4)*x852))+(((-0.321)*cj30*x852)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x854=IKsin(j28);
IkReal x855=IKcos(j28);
IkReal x856=(gconst31*py);
IkReal x857=(gconst32*px);
IkReal x858=((0.321)*cj30);
IkReal x859=((0.8)*x855);
evalcond[0]=(((x854*x858))+(((0.4)*x854)));
evalcond[1]=((((-0.1)*x854))+((x854*x856))+((x854*x857)));
evalcond[2]=((0.1)+((x855*x858))+(((-1.0)*x856))+(((-1.0)*x857))+(((0.4)*x855)));
evalcond[3]=((-0.32)+((x856*x859))+(((-0.2568)*cj30))+(((-0.08)*x855))+((x857*x859)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x860=((((100.0)*(px*px)))+(((100.0)*(py*py))));
IkReal x867 = x860;
if(IKabs(x867)==0){
continue;
}
IkReal x861=pow(x867,-0.5);
if((x860) < -0.00001)
continue;
IkReal x862=IKabs(IKsqrt(x860));
CheckValue<IkReal> x868=IKPowWithIntegerCheck(x862,-1);
if(!x868.valid){
continue;
}
IkReal x863=x868.value;
IkReal x864=((10.0)*px*x861);
IkReal x865=((10.0)*py*x861);
if((((1.0)+(((-1.0)*(x863*x863))))) < -0.00001)
continue;
IkReal x866=IKsqrt(((1.0)+(((-1.0)*(x863*x863)))));
if( (x863) < -1-IKFAST_SINCOS_THRESH || (x863) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x869 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x869.valid){
continue;
}
IkReal gconst33=((3.14159265358979)+(IKasin(x863))+(((-1.0)*(x869.value))));
IkReal gconst34=(((x863*x865))+(((-1.0)*x864*x866)));
IkReal gconst35=(((x863*x864))+((x865*x866)));
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x870=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x870.valid){
continue;
}
if( (x870.value) < -1-IKFAST_SINCOS_THRESH || (x870.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x871 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x871.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(((-1.0)*(IKasin(x870.value))))+j27+(x871.value))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x873=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst34*py))+(((-1.0)*gconst35*px))),-1);
if(!x873.valid){
continue;
}
IkReal x872=x873.value;
cj28array[0]=((((-0.4)*x872))+(((-0.321)*cj30*x872)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x874=IKsin(j28);
IkReal x875=IKcos(j28);
IkReal x876=(gconst34*py);
IkReal x877=(gconst35*px);
IkReal x878=((0.321)*cj30);
IkReal x879=((0.8)*x875);
evalcond[0]=(((x874*x878))+(((0.4)*x874)));
evalcond[1]=(((x874*x877))+((x874*x876))+(((-0.1)*x874)));
evalcond[2]=((0.1)+(((-1.0)*x876))+(((-1.0)*x877))+(((0.4)*x875))+((x875*x878)));
evalcond[3]=((-0.32)+((x876*x879))+(((-0.2568)*cj30))+(((-0.08)*x875))+((x877*x879)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j28]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x881=IKPowWithIntegerCheck(((0.4)+(((0.321)*cj30))),-1);
if(!x881.valid){
continue;
}
IkReal x880=x881.value;
cj28array[0]=(((py*sj27*x880))+((cj27*px*x880))+(((-0.1)*x880)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x882=IKsin(j28);
IkReal x883=IKcos(j28);
IkReal x884=((0.321)*cj30);
IkReal x885=(py*sj27*x883);
IkReal x886=(cj27*px*x883);
evalcond[0]=(((x882*x884))+(((0.4)*x882)));
evalcond[1]=(((py*sj27*x882))+((cj27*px*x882))+(((-0.1)*x882)));
evalcond[2]=((0.4)+(((-1.0)*x885))+(((-1.0)*x886))+x884+(((0.1)*x883)));
evalcond[3]=((-0.32)+(((0.8)*x885))+(((0.8)*x886))+(((-0.2568)*cj30))+(((-0.08)*x883)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x888=IKPowWithIntegerCheck(((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))),-1);
if(!x888.valid){
continue;
}
IkReal x887=x888.value;
cj28array[0]=((((-0.4)*x887))+(((-0.321)*cj30*x887)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x889=IKsin(j28);
IkReal x890=IKcos(j28);
IkReal x891=(py*sj27);
IkReal x892=(cj27*px);
IkReal x893=((0.321)*cj30);
IkReal x894=((0.8)*x890);
evalcond[0]=((((0.4)*x889))+((x889*x893)));
evalcond[1]=(((x889*x891))+((x889*x892))+(((-0.1)*x889)));
evalcond[2]=((0.1)+(((0.4)*x890))+(((-1.0)*x892))+(((-1.0)*x891))+((x890*x893)));
evalcond[3]=((-0.32)+(((-0.2568)*cj30))+((x892*x894))+((x891*x894))+(((-0.08)*x890)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j30), 6.28318530717959))))));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
evalcond[2]=((0.509841)+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
cj28array[0]=((-0.13869625520111)+(((1.3869625520111)*py*sj27))+(((1.3869625520111)*cj27*px)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x895=IKcos(j28);
IkReal x896=px*px;
CheckValue<IkReal> x905=IKPowWithIntegerCheck(py,-1);
if(!x905.valid){
continue;
}
IkReal x897=x905.value;
IkReal x898=IKsin(j28);
IkReal x899=(py*sj27);
IkReal x900=(x896*x897);
IkReal x901=((1.0)*x895);
IkReal x902=(sj29*x898);
IkReal x903=(cj29*x898);
IkReal x904=((0.8)*sj27*x895);
evalcond[0]=((0.721)*x898);
evalcond[1]=((0.721)+(((-1.0)*cj27*px*x901))+(((-1.0)*x899*x901))+(((0.1)*x895)));
evalcond[2]=((-0.5768)+((x900*x904))+(((0.8)*x895*x899))+(((-0.08)*x895)));
evalcond[3]=(((sj27*x900*x903))+((x899*x903))+(((-0.1)*x903)));
evalcond[4]=((((-1.0)*sj27*x900*x902))+(((-1.0)*x899*x902))+(((0.1)*x902)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(j30, 6.28318530717959))))));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
evalcond[2]=((-0.003759)+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
cj28array[0]=((-1.26582278481013)+(((12.6582278481013)*py*sj27))+(((12.6582278481013)*cj27*px)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x906=IKcos(j28);
IkReal x907=px*px;
CheckValue<IkReal> x916=IKPowWithIntegerCheck(py,-1);
if(!x916.valid){
continue;
}
IkReal x908=x916.value;
IkReal x909=IKsin(j28);
IkReal x910=(py*sj27);
IkReal x911=(x907*x908);
IkReal x912=((1.0)*x906);
IkReal x913=(sj29*x909);
IkReal x914=(cj29*x909);
IkReal x915=((0.8)*sj27*x906);
evalcond[0]=((0.079)*x909);
evalcond[1]=((0.079)+(((-1.0)*cj27*px*x912))+(((-1.0)*x910*x912))+(((0.1)*x906)));
evalcond[2]=((-0.0632)+(((0.8)*x906*x910))+((x911*x915))+(((-0.08)*x906)));
evalcond[3]=(((x910*x914))+(((-0.1)*x914))+((sj27*x911*x914)));
evalcond[4]=((((-1.0)*sj27*x911*x913))+(((-1.0)*x910*x913))+(((0.1)*x913)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j28]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x917=cj27*cj27;
IkReal x918=py*py;
IkReal x919=(cj27*px);
IkReal x920=(cj29*sj30);
IkReal x921=(py*sj27);
IkReal x922=((1000.0)*pz);
IkReal x923=((1000.0)*x917);
CheckValue<IkReal> x924=IKPowWithIntegerCheck(IKsign(((((32.1)*x920))+(((321.0)*cj30*pz))+(((-321.0)*x920*x921))+(((400.0)*pz))+(((-321.0)*x919*x920)))),-1);
if(!x924.valid){
continue;
}
CheckValue<IkReal> x925 = IKatan2WithCheck(IkReal(((-150.0)+((x923*(px*px)))+(((-200.0)*x921))+(((-200.0)*x919))+(((-1.0)*x918*x923))+(((1000.0)*x918))+(((2000.0)*x919*x921))+(((-103.041)*(cj30*cj30)))+(((-256.8)*cj30)))),((((-100.0)*pz))+(((-103.041)*cj30*x920))+((x919*x922))+((x921*x922))+(((-128.4)*x920))),IKFAST_ATAN2_MAGTHRESH);
if(!x925.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x924.value)))+(x925.value));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[6];
IkReal x926=IKsin(j28);
IkReal x927=IKcos(j28);
IkReal x928=((0.321)*cj30);
IkReal x929=(py*sj27);
IkReal x930=((0.321)*sj30);
IkReal x931=((1.0)*sj29);
IkReal x932=(px*sj27);
IkReal x933=(cj27*px);
IkReal x934=(cj27*py);
IkReal x935=((1.0)*x929);
IkReal x936=(pz*x926);
IkReal x937=(cj29*x926);
IkReal x938=(pz*x927);
IkReal x939=((0.8)*x927);
IkReal x940=(sj29*x926);
evalcond[0]=(((cj29*x927*x930))+pz+(((0.4)*x926))+((x926*x928)));
evalcond[1]=((0.1)+(((-1.0)*x930*x937))+((x927*x928))+(((-1.0)*x933))+(((0.4)*x927))+(((-1.0)*x935)));
evalcond[2]=((0.4)+(((0.1)*x927))+(((-1.0)*x927*x935))+x936+x928+(((-1.0)*x927*x933)));
evalcond[3]=((-0.066959)+(((-0.08)*x927))+(((0.2)*x933))+(((0.2)*x929))+(((-0.8)*x936))+(((-1.0)*pp))+((x929*x939))+((x933*x939)));
evalcond[4]=((((-1.0)*x926*x929*x931))+(((-1.0)*x931*x938))+(((-1.0)*x926*x931*x933))+((cj29*x932))+(((-1.0)*cj29*x934))+(((0.1)*x940)));
evalcond[5]=((((-0.1)*x937))+(((-1.0)*x931*x934))+((cj29*x938))+((sj29*x932))+x930+((x929*x937))+((x933*x937)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x941=cj29*cj29;
IkReal x942=cj30*cj30;
IkReal x943=(cj27*px);
IkReal x944=((321000.0)*cj30);
IkReal x945=(py*sj27);
IkReal x946=((321000.0)*cj29*sj30);
IkReal x947=((103041.0)*x941);
CheckValue<IkReal> x948=IKPowWithIntegerCheck(IKsign(((160000.0)+(((256800.0)*cj30))+(((-1.0)*x942*x947))+(((103041.0)*x942))+x947)),-1);
if(!x948.valid){
continue;
}
CheckValue<IkReal> x949 = IKatan2WithCheck(IkReal(((((-1.0)*pz*x944))+(((-1.0)*x945*x946))+(((32100.0)*cj29*sj30))+(((-400000.0)*pz))+(((-1.0)*x943*x946)))),((-40000.0)+(((-1.0)*pz*x946))+(((-32100.0)*cj30))+((x943*x944))+((x944*x945))+(((400000.0)*x943))+(((400000.0)*x945))),IKFAST_ATAN2_MAGTHRESH);
if(!x949.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x948.value)))+(x949.value));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[6];
IkReal x950=IKsin(j28);
IkReal x951=IKcos(j28);
IkReal x952=((0.321)*cj30);
IkReal x953=(py*sj27);
IkReal x954=((0.321)*sj30);
IkReal x955=((1.0)*sj29);
IkReal x956=(px*sj27);
IkReal x957=(cj27*px);
IkReal x958=(cj27*py);
IkReal x959=((1.0)*x953);
IkReal x960=(pz*x950);
IkReal x961=(cj29*x950);
IkReal x962=(pz*x951);
IkReal x963=((0.8)*x951);
IkReal x964=(sj29*x950);
evalcond[0]=(pz+((cj29*x951*x954))+(((0.4)*x950))+((x950*x952)));
evalcond[1]=((0.1)+((x951*x952))+(((-1.0)*x957))+(((-1.0)*x959))+(((0.4)*x951))+(((-1.0)*x954*x961)));
evalcond[2]=((0.4)+(((0.1)*x951))+(((-1.0)*x951*x957))+(((-1.0)*x951*x959))+x960+x952);
evalcond[3]=((-0.066959)+(((-0.8)*x960))+(((-1.0)*pp))+((x957*x963))+(((0.2)*x953))+(((0.2)*x957))+(((-0.08)*x951))+((x953*x963)));
evalcond[4]=((((0.1)*x964))+(((-1.0)*cj29*x958))+((cj29*x956))+(((-1.0)*x950*x955*x957))+(((-1.0)*x950*x953*x955))+(((-1.0)*x955*x962)));
evalcond[5]=(((sj29*x956))+(((-0.1)*x961))+((cj29*x962))+((x957*x961))+(((-1.0)*x955*x958))+x954+((x953*x961)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x965=(py*sj27);
IkReal x966=(cj29*sj30);
IkReal x967=((321.0)*cj30);
IkReal x968=(cj27*px);
IkReal x969=((1000.0)*pz);
CheckValue<IkReal> x970 = IKatan2WithCheck(IkReal(((((-103.041)*cj30*x966))+(((100.0)*pz))+(((-1.0)*x965*x969))+(((-128.4)*x966))+(((-1.0)*x968*x969)))),((160.0)+(((-1.0)*pz*x969))+(((103.041)*(cj30*cj30)))+(((256.8)*cj30))),IKFAST_ATAN2_MAGTHRESH);
if(!x970.valid){
continue;
}
CheckValue<IkReal> x971=IKPowWithIntegerCheck(IKsign(((-40.0)+(((321.0)*pz*x966))+(((400.0)*x965))+(((400.0)*x968))+((x967*x968))+((x965*x967))+(((-32.1)*cj30)))),-1);
if(!x971.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(x970.value)+(((1.5707963267949)*(x971.value))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[6];
IkReal x972=IKsin(j28);
IkReal x973=IKcos(j28);
IkReal x974=((0.321)*cj30);
IkReal x975=(py*sj27);
IkReal x976=((0.321)*sj30);
IkReal x977=((1.0)*sj29);
IkReal x978=(px*sj27);
IkReal x979=(cj27*px);
IkReal x980=(cj27*py);
IkReal x981=((1.0)*x975);
IkReal x982=(pz*x972);
IkReal x983=(cj29*x972);
IkReal x984=(pz*x973);
IkReal x985=((0.8)*x973);
IkReal x986=(sj29*x972);
evalcond[0]=(((cj29*x973*x976))+pz+(((0.4)*x972))+((x972*x974)));
evalcond[1]=((0.1)+(((-1.0)*x981))+(((-1.0)*x979))+((x973*x974))+(((-1.0)*x976*x983))+(((0.4)*x973)));
evalcond[2]=((0.4)+(((0.1)*x973))+(((-1.0)*x973*x979))+x982+x974+(((-1.0)*x973*x981)));
evalcond[3]=((-0.066959)+(((-0.8)*x982))+((x975*x985))+((x979*x985))+(((-1.0)*pp))+(((0.2)*x975))+(((0.2)*x979))+(((-0.08)*x973)));
evalcond[4]=((((0.1)*x986))+(((-1.0)*cj29*x980))+((cj29*x978))+(((-1.0)*x977*x984))+(((-1.0)*x972*x977*x979))+(((-1.0)*x972*x975*x977)));
evalcond[5]=((((-0.1)*x983))+((x975*x983))+((sj29*x978))+((x979*x983))+((cj29*x984))+(((-1.0)*x977*x980))+x976);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x987=cj27*cj27;
IkReal x988=px*px;
IkReal x989=py*py;
IkReal x990=((1.0)*pz);
IkReal x991=(cj27*px);
IkReal x992=((5.0)*pp);
IkReal x993=(cj29*py);
IkReal x994=((4.0)*cj27);
IkReal x995=(pz*sj29);
IkReal x996=(cj29*sj27);
IkReal x997=(py*sj27*sj29);
IkReal x998=((4.0)*cj29*px);
IkReal x999=(sj29*x987);
IkReal x1000=((4.0)*x989);
CheckValue<IkReal> x1001 = IKatan2WithCheck(IkReal(((((0.4)*px*x996))+((x992*x995))+(((-1.0)*x990*x997))+(((0.334795)*x995))+(((-4.0)*px*x993))+(((-1.0)*sj29*x990*x991))+(((-0.4)*cj27*x993))+((x989*x994*x996))+(((8.0)*px*x987*x993))+(((-1.0)*x988*x994*x996)))),((((-4.0)*px*pz*x996))+(((2.0)*x991*x997))+(((0.5)*pp*sj29))+((x988*x999))+(((-1.0)*x989*x999))+(((-1.0)*x992*x997))+((sj29*x989))+((pz*x993*x994))+(((-1.0)*sj29*x991*x992))+(((0.0334795)*sj29))+(((-0.434795)*sj29*x991))+(((-0.434795)*x997))),IKFAST_ATAN2_MAGTHRESH);
if(!x1001.valid){
continue;
}
CheckValue<IkReal> x1002=IKPowWithIntegerCheck(IKsign((((x1000*x999))+(((-8.0)*x991*x997))+(((0.8)*sj29*x991))+(((-0.04)*sj29))+(((-4.0)*x988*x999))+(((0.8)*x997))+(((-1.0)*sj29*x1000))+(((-4.0)*pz*x995)))),-1);
if(!x1002.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(x1001.value)+(((1.5707963267949)*(x1002.value))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[2];
IkReal x1003=IKcos(j28);
IkReal x1004=IKsin(j28);
IkReal x1005=(py*sj27);
IkReal x1006=((1.0)*cj27);
IkReal x1007=(cj27*px);
IkReal x1008=((0.8)*x1003);
IkReal x1009=(sj29*x1004);
evalcond[0]=((-0.066959)+(((0.2)*x1007))+(((0.2)*x1005))+(((-0.8)*pz*x1004))+(((-0.08)*x1003))+(((-1.0)*pp))+((x1005*x1008))+((x1007*x1008)));
evalcond[1]=((((0.1)*x1009))+((cj29*px*sj27))+(((-1.0)*pz*sj29*x1003))+(((-1.0)*cj29*py*x1006))+(((-1.0)*x1005*x1009))+(((-1.0)*px*x1006*x1009)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j30eval[1];
j30eval[0]=sj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal j30eval[2];
j30eval[0]=cj28;
j30eval[1]=cj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  || IKabs(j30eval[1]) < 0.0000010000000000  )
{
{
IkReal j30eval[2];
j30eval[0]=sj29;
j30eval[1]=sj28;
if( IKabs(j30eval[0]) < 0.0000010000000000  || IKabs(j30eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x1010=(cj27*px);
IkReal x1011=((0.8)*cj28);
IkReal x1012=(py*sj27);
IkReal x1013=((((-1.0)*cj27*py))+((px*sj27)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
evalcond[1]=x1013;
evalcond[2]=((-0.066959)+(((-0.08)*cj28))+(((-1.0)*pp))+(((0.2)*x1010))+(((0.2)*x1012))+((x1011*x1012))+((x1010*x1011))+(((-0.8)*pz*sj28)));
evalcond[3]=x1013;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x1014=((3.11526479750779)*cj28);
IkReal x1015=(py*sj27);
IkReal x1016=((3.11526479750779)*sj28);
IkReal x1017=(cj27*px);
if( IKabs(((((-1.0)*pz*x1014))+(((-1.0)*x1015*x1016))+(((-1.0)*x1016*x1017))+(((0.311526479750779)*sj28)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+((x1014*x1017))+((x1014*x1015))+(((-0.311526479750779)*cj28))+(((-1.0)*pz*x1016)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*pz*x1014))+(((-1.0)*x1015*x1016))+(((-1.0)*x1016*x1017))+(((0.311526479750779)*sj28))))+IKsqr(((-1.24610591900312)+((x1014*x1017))+((x1014*x1015))+(((-0.311526479750779)*cj28))+(((-1.0)*pz*x1016))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-1.0)*pz*x1014))+(((-1.0)*x1015*x1016))+(((-1.0)*x1016*x1017))+(((0.311526479750779)*sj28))), ((-1.24610591900312)+((x1014*x1017))+((x1014*x1015))+(((-0.311526479750779)*cj28))+(((-1.0)*pz*x1016))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1018=IKcos(j30);
IkReal x1019=IKsin(j30);
IkReal x1020=(py*sj27);
IkReal x1021=(cj27*px);
IkReal x1022=((0.321)*x1018);
IkReal x1023=((0.321)*x1019);
evalcond[0]=((((0.4)*sj28))+((cj28*x1023))+((sj28*x1022))+pz);
evalcond[1]=((0.253041)+(((0.2568)*x1018))+(((-1.0)*pp))+(((0.2)*x1021))+(((0.2)*x1020)));
evalcond[2]=(x1023+((cj28*pz))+((sj28*x1021))+((sj28*x1020))+(((-0.1)*sj28)));
CheckValue<IkReal> x1024=IKPowWithIntegerCheck(py,-1);
if(!x1024.valid){
continue;
}
evalcond[3]=((0.31630125)+x1022+(((-1.25)*pp))+(((0.25)*x1020))+(((0.25)*sj27*(px*px)*(x1024.value))));
evalcond[4]=((0.1)+(((-1.0)*x1021))+(((-1.0)*x1020))+(((0.4)*cj28))+((cj28*x1022))+(((-1.0)*sj28*x1023)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1025=(cj27*px);
IkReal x1026=((0.8)*cj28);
IkReal x1027=(cj27*py);
IkReal x1028=(px*sj27);
IkReal x1029=(py*sj27);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
evalcond[1]=(x1028+(((-1.0)*x1027)));
evalcond[2]=((-0.066959)+(((-0.08)*cj28))+(((-1.0)*pp))+((x1026*x1029))+((x1025*x1026))+(((0.2)*x1025))+(((0.2)*x1029))+(((-0.8)*pz*sj28)));
evalcond[3]=(x1027+(((-1.0)*x1028)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x1030=((3.11526479750779)*cj28);
IkReal x1031=(py*sj27);
IkReal x1032=((3.11526479750779)*sj28);
IkReal x1033=(cj27*px);
if( IKabs((((x1031*x1032))+((pz*x1030))+(((-0.311526479750779)*sj28))+((x1032*x1033)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+((x1030*x1033))+((x1030*x1031))+(((-0.311526479750779)*cj28))+(((-1.0)*pz*x1032)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x1031*x1032))+((pz*x1030))+(((-0.311526479750779)*sj28))+((x1032*x1033))))+IKsqr(((-1.24610591900312)+((x1030*x1033))+((x1030*x1031))+(((-0.311526479750779)*cj28))+(((-1.0)*pz*x1032))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2((((x1031*x1032))+((pz*x1030))+(((-0.311526479750779)*sj28))+((x1032*x1033))), ((-1.24610591900312)+((x1030*x1033))+((x1030*x1031))+(((-0.311526479750779)*cj28))+(((-1.0)*pz*x1032))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1034=IKcos(j30);
IkReal x1035=IKsin(j30);
IkReal x1036=(cj27*px);
IkReal x1037=((1.0)*sj28);
IkReal x1038=((0.25)*sj27);
IkReal x1039=(py*sj27);
IkReal x1040=((0.321)*x1034);
IkReal x1041=((0.321)*x1035);
evalcond[0]=((((0.4)*sj28))+((sj28*x1040))+pz+(((-1.0)*cj28*x1041)));
evalcond[1]=((0.253041)+(((0.2568)*x1034))+(((-1.0)*pp))+(((0.2)*x1039))+(((0.2)*x1036)));
CheckValue<IkReal> x1042=IKPowWithIntegerCheck(py,-1);
if(!x1042.valid){
continue;
}
evalcond[2]=((0.31630125)+x1040+(((-1.25)*pp))+((py*x1038))+((x1038*(px*px)*(x1042.value))));
evalcond[3]=((((-1.0)*x1037*x1039))+x1041+(((-1.0)*x1036*x1037))+(((0.1)*sj28))+(((-1.0)*cj28*pz)));
evalcond[4]=((0.1)+((sj28*x1041))+(((-1.0)*x1036))+(((-1.0)*x1039))+(((0.4)*cj28))+((cj28*x1040)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j28))), 6.28318530717959)));
evalcond[1]=((-0.146959)+((cj27*px))+(((-1.0)*pp))+((py*sj27)));
evalcond[2]=(((cj29*px*sj27))+(((-1.0)*cj27*cj29*py))+(((-1.0)*pz*sj29)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30eval[1];
sj28=0;
cj28=1.0;
j28=0;
j30eval[0]=cj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal j30eval[1];
sj28=0;
cj28=1.0;
j28=0;
j30eval[0]=sj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-3.11526479750779)*pz), ((-1.09981619937695)+(((3.11526479750779)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1043=IKcos(j30);
evalcond[0]=(pz+(((0.321)*(IKsin(j30)))));
evalcond[1]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1043)));
evalcond[2]=((0.353041)+(((0.321)*x1043))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((3.11526479750779)*pz), ((-1.09981619937695)+(((3.11526479750779)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1044=IKcos(j30);
evalcond[0]=((((-0.321)*(IKsin(j30))))+pz);
evalcond[1]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1044)));
evalcond[2]=((0.353041)+(((0.321)*x1044))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.09981619937695)+(((3.11526479750779)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1045=IKcos(j30);
evalcond[0]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1045)));
evalcond[1]=((0.353041)+(((0.321)*x1045))+(((-1.0)*pp)));
evalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.09981619937695)+(((3.11526479750779)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1046=IKcos(j30);
evalcond[0]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1046)));
evalcond[1]=((0.353041)+(((0.321)*x1046))+(((-1.0)*pp)));
evalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j30]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1047=IKPowWithIntegerCheck(sj29,-1);
if(!x1047.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1047.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1047.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1047.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.09981619937695)+(((3.11526479750779)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1048=IKcos(j30);
IkReal x1049=IKsin(j30);
IkReal x1050=(px*sj27);
IkReal x1051=((1.0)*cj27*py);
IkReal x1052=((0.321)*x1049);
evalcond[0]=(pz+((cj29*x1052)));
evalcond[1]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1048)));
evalcond[2]=((0.353041)+(((0.321)*x1048))+(((-1.0)*pp)));
evalcond[3]=((((-1.0)*x1051))+x1050+((sj29*x1052)));
evalcond[4]=(x1052+((cj29*pz))+(((-1.0)*sj29*x1051))+((sj29*x1050)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1053=IKPowWithIntegerCheck(cj29,-1);
if(!x1053.valid){
continue;
}
if( IKabs(((-3.11526479750779)*pz*(x1053.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz*(x1053.value)))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-3.11526479750779)*pz*(x1053.value)), ((-1.09981619937695)+(((3.11526479750779)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1054=IKcos(j30);
IkReal x1055=IKsin(j30);
IkReal x1056=(px*sj27);
IkReal x1057=((1.0)*cj27*py);
IkReal x1058=((0.321)*x1055);
evalcond[0]=(pz+((cj29*x1058)));
evalcond[1]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1054)));
evalcond[2]=((0.353041)+(((0.321)*x1054))+(((-1.0)*pp)));
evalcond[3]=((((-1.0)*x1057))+x1056+((sj29*x1058)));
evalcond[4]=(x1058+((cj29*pz))+(((-1.0)*sj29*x1057))+((sj29*x1056)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j28)))), 6.28318530717959)));
evalcond[1]=((0.013041)+(((-0.6)*cj27*px))+(((-1.0)*pp))+(((-0.6)*py*sj27)));
evalcond[2]=(((cj29*px*sj27))+(((-1.0)*cj27*cj29*py))+((pz*sj29)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30eval[1];
sj28=0;
cj28=-1.0;
j28=3.14159265358979;
j30eval[0]=cj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal j30eval[1];
sj28=0;
cj28=-1.0;
j28=3.14159265358979;
j30eval[0]=sj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((3.11526479750779)*pz), ((-1.00228971962617)+(((5.19210799584631)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1059=IKcos(j30);
evalcond[0]=((((-0.321)*(IKsin(j30))))+pz);
evalcond[1]=((0.257388)+(((0.2568)*x1059))+(((-1.33333333333333)*pp)));
evalcond[2]=((0.321735)+(((0.321)*x1059))+(((-1.66666666666667)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-3.11526479750779)*pz), ((-1.00228971962617)+(((5.19210799584631)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1060=IKcos(j30);
evalcond[0]=(pz+(((0.321)*(IKsin(j30)))));
evalcond[1]=((0.257388)+(((0.2568)*x1060))+(((-1.33333333333333)*pp)));
evalcond[2]=((0.321735)+(((0.321)*x1060))+(((-1.66666666666667)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.00228971962617)+(((5.19210799584631)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1061=IKcos(j30);
evalcond[0]=((0.257388)+(((0.2568)*x1061))+(((-1.33333333333333)*pp)));
evalcond[1]=((0.321735)+(((0.321)*x1061))+(((-1.66666666666667)*pp)));
evalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.00228971962617)+(((5.19210799584631)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1062=IKcos(j30);
evalcond[0]=((0.257388)+(((0.2568)*x1062))+(((-1.33333333333333)*pp)));
evalcond[1]=((0.321735)+(((0.321)*x1062))+(((-1.66666666666667)*pp)));
evalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j30]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1063=IKPowWithIntegerCheck(sj29,-1);
if(!x1063.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1063.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1063.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1063.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.00228971962617)+(((5.19210799584631)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1064=IKcos(j30);
IkReal x1065=IKsin(j30);
IkReal x1066=(px*sj27);
IkReal x1067=((1.0)*cj27*py);
IkReal x1068=((0.321)*x1065);
evalcond[0]=(pz+(((-1.0)*cj29*x1068)));
evalcond[1]=((0.257388)+(((0.2568)*x1064))+(((-1.33333333333333)*pp)));
evalcond[2]=((0.321735)+(((0.321)*x1064))+(((-1.66666666666667)*pp)));
evalcond[3]=(x1066+(((-1.0)*x1067))+((sj29*x1068)));
evalcond[4]=(x1068+(((-1.0)*sj29*x1067))+(((-1.0)*cj29*pz))+((sj29*x1066)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1069=IKPowWithIntegerCheck(cj29,-1);
if(!x1069.valid){
continue;
}
if( IKabs(((3.11526479750779)*pz*(x1069.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz*(x1069.value)))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((3.11526479750779)*pz*(x1069.value)), ((-1.00228971962617)+(((5.19210799584631)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1070=IKcos(j30);
IkReal x1071=IKsin(j30);
IkReal x1072=(px*sj27);
IkReal x1073=((1.0)*cj27*py);
IkReal x1074=((0.321)*x1071);
evalcond[0]=(pz+(((-1.0)*cj29*x1074)));
evalcond[1]=((0.257388)+(((0.2568)*x1070))+(((-1.33333333333333)*pp)));
evalcond[2]=((0.321735)+(((0.321)*x1070))+(((-1.66666666666667)*pp)));
evalcond[3]=(x1072+((sj29*x1074))+(((-1.0)*x1073)));
evalcond[4]=((((-1.0)*sj29*x1073))+x1074+(((-1.0)*cj29*pz))+((sj29*x1072)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1075=(cj27*px);
IkReal x1076=((1.0)*py);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j28)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+(((-0.8)*pz))+(((0.2)*x1075))+(((-1.0)*pp))+(((0.2)*py*sj27)));
evalcond[2]=((((-1.0)*cj27*cj29*x1076))+(((-1.0)*sj27*sj29*x1076))+((cj29*px*sj27))+(((-1.0)*sj29*x1075))+(((0.1)*sj29)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30eval[1];
sj28=1.0;
cj28=0;
j28=1.5707963267949;
j30eval[0]=sj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal j30eval[1];
sj28=1.0;
cj28=0;
j28=1.5707963267949;
j30eval[0]=cj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1077=IKcos(j30);
evalcond[0]=((0.4)+(((0.321)*x1077))+pz);
evalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1077)));
evalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1078=IKcos(j30);
evalcond[0]=((0.4)+(((0.321)*x1078))+pz);
evalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1078)));
evalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1079=IKcos(j30);
evalcond[0]=((0.4)+(((0.321)*x1079))+pz);
evalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1079)));
evalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((-0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1080=IKcos(j30);
evalcond[0]=((0.4)+(((0.321)*x1080))+pz);
evalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1080)));
evalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j30]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1081=IKPowWithIntegerCheck(cj29,-1);
if(!x1081.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1081.value)*(((100.0)+(((-1000.0)*cj27*px))+(((-1000.0)*py*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1081.value)*(((100.0)+(((-1000.0)*cj27*px))+(((-1000.0)*py*sj27))))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1081.value)*(((100.0)+(((-1000.0)*cj27*px))+(((-1000.0)*py*sj27))))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1082=IKcos(j30);
IkReal x1083=IKsin(j30);
IkReal x1084=((1.0)*py);
IkReal x1085=(cj27*px);
IkReal x1086=(px*sj27);
IkReal x1087=((0.321)*x1083);
evalcond[0]=((0.4)+(((0.321)*x1082))+pz);
evalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1082)));
evalcond[2]=(x1086+((sj29*x1087))+(((-1.0)*cj27*x1084)));
evalcond[3]=((0.1)+(((-1.0)*x1085))+(((-1.0)*sj27*x1084))+(((-1.0)*cj29*x1087)));
evalcond[4]=(((cj29*py*sj27))+x1087+((sj29*x1086))+(((-1.0)*cj27*sj29*x1084))+((cj29*x1085))+(((-0.1)*cj29)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1088=IKPowWithIntegerCheck(sj29,-1);
if(!x1088.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1088.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1088.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1088.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1089=IKcos(j30);
IkReal x1090=IKsin(j30);
IkReal x1091=((1.0)*py);
IkReal x1092=(cj27*px);
IkReal x1093=(px*sj27);
IkReal x1094=((0.321)*x1090);
evalcond[0]=((0.4)+(((0.321)*x1089))+pz);
evalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1089)));
evalcond[2]=(x1093+((sj29*x1094))+(((-1.0)*cj27*x1091)));
evalcond[3]=((0.1)+(((-1.0)*x1092))+(((-1.0)*cj29*x1094))+(((-1.0)*sj27*x1091)));
evalcond[4]=(((cj29*py*sj27))+x1094+((cj29*x1092))+((sj29*x1093))+(((-1.0)*cj27*sj29*x1091))+(((-0.1)*cj29)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1095=(py*sj27);
IkReal x1096=(cj27*px);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j28)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+(((0.8)*pz))+(((-1.0)*pp))+(((0.2)*x1096))+(((0.2)*x1095)));
evalcond[2]=(((cj29*px*sj27))+(((-1.0)*cj27*cj29*py))+((sj29*x1096))+((sj29*x1095))+(((-0.1)*sj29)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30eval[1];
sj28=-1.0;
cj28=0;
j28=-1.5707963267949;
j30eval[0]=sj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal j30eval[1];
sj28=-1.0;
cj28=0;
j28=-1.5707963267949;
j30eval[0]=cj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1097=IKcos(j30);
evalcond[0]=((-0.4)+(((-0.321)*x1097))+pz);
evalcond[1]=((0.32)+(((0.2568)*x1097))+(((-0.8)*pz)));
evalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1098=IKcos(j30);
evalcond[0]=((-0.4)+(((-0.321)*x1098))+pz);
evalcond[1]=((0.32)+(((0.2568)*x1098))+(((-0.8)*pz)));
evalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1099=IKcos(j30);
evalcond[0]=((-0.4)+(((-0.321)*x1099))+pz);
evalcond[1]=((0.32)+(((0.2568)*x1099))+(((-0.8)*pz)));
evalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1100=IKcos(j30);
evalcond[0]=((-0.4)+(((-0.321)*x1100))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1100)));
evalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((-0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j30]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1101=IKPowWithIntegerCheck(cj29,-1);
if(!x1101.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1101.value)*(((-100.0)+(((1000.0)*cj27*px))+(((1000.0)*py*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1101.value)*(((-100.0)+(((1000.0)*cj27*px))+(((1000.0)*py*sj27))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1101.value)*(((-100.0)+(((1000.0)*cj27*px))+(((1000.0)*py*sj27))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1102=IKcos(j30);
IkReal x1103=IKsin(j30);
IkReal x1104=((1.0)*py);
IkReal x1105=(px*sj27);
IkReal x1106=((1.0)*cj27*px);
IkReal x1107=((0.321)*x1103);
evalcond[0]=((-0.4)+(((-0.321)*x1102))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1102)));
evalcond[2]=(x1105+(((-1.0)*cj27*x1104))+((sj29*x1107)));
evalcond[3]=((0.1)+((cj29*x1107))+(((-1.0)*sj27*x1104))+(((-1.0)*x1106)));
evalcond[4]=(x1107+(((-1.0)*cj27*sj29*x1104))+((sj29*x1105))+(((0.1)*cj29))+(((-1.0)*cj29*x1106))+(((-1.0)*cj29*sj27*x1104)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1108=IKPowWithIntegerCheck(sj29,-1);
if(!x1108.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1108.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1108.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1108.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1109=IKcos(j30);
IkReal x1110=IKsin(j30);
IkReal x1111=((1.0)*py);
IkReal x1112=(px*sj27);
IkReal x1113=((1.0)*cj27*px);
IkReal x1114=((0.321)*x1110);
evalcond[0]=((-0.4)+(((-0.321)*x1109))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1109)));
evalcond[2]=(x1112+(((-1.0)*cj27*x1111))+((sj29*x1114)));
evalcond[3]=((0.1)+(((-1.0)*sj27*x1111))+(((-1.0)*x1113))+((cj29*x1114)));
evalcond[4]=(x1114+(((-1.0)*cj27*sj29*x1111))+((sj29*x1112))+(((-1.0)*cj29*x1113))+(((0.1)*cj29))+(((-1.0)*cj29*sj27*x1111)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1115=(cj27*px);
IkReal x1116=((0.8)*cj28);
IkReal x1117=(py*sj27);
IkReal x1118=((1.0)*sj28);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+(((-0.08)*cj28))+(((-1.0)*pp))+((x1116*x1117))+((x1115*x1116))+(((0.2)*x1115))+(((0.2)*x1117))+(((-0.8)*pz*sj28)));
evalcond[2]=((((0.1)*sj28))+(((-1.0)*cj28*pz))+(((-1.0)*x1115*x1118))+(((-1.0)*x1117*x1118)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1119=IKcos(j30);
IkReal x1120=((1.0)*py);
IkReal x1121=(cj27*px);
IkReal x1122=((0.321)*x1119);
evalcond[0]=((((0.4)*sj28))+((sj28*x1122))+pz);
evalcond[1]=((((-1.0)*cj27*x1120))+((px*sj27))+(((0.321)*(IKsin(j30)))));
evalcond[2]=((0.253041)+(((-1.0)*pp))+(((0.2)*x1121))+(((0.2)*py*sj27))+(((0.2568)*x1119)));
evalcond[3]=((0.1)+(((0.4)*cj28))+(((-1.0)*sj27*x1120))+(((-1.0)*x1121))+((cj28*x1122)));
evalcond[4]=((0.4)+x1122+(((-1.0)*cj28*sj27*x1120))+(((-1.0)*cj28*x1121))+(((0.1)*cj28))+((pz*sj28)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1123=(cj27*px);
IkReal x1124=((0.8)*cj28);
IkReal x1125=(py*sj27);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+((x1124*x1125))+(((-0.08)*cj28))+(((-1.0)*pp))+(((0.2)*x1125))+(((0.2)*x1123))+((x1123*x1124))+(((-0.8)*pz*sj28)));
evalcond[2]=(((sj28*x1123))+((sj28*x1125))+((cj28*pz))+(((-0.1)*sj28)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1126=IKcos(j30);
IkReal x1127=((1.0)*py);
IkReal x1128=(cj27*px);
IkReal x1129=((0.321)*x1126);
evalcond[0]=((((0.4)*sj28))+((sj28*x1129))+pz);
evalcond[1]=((((-0.321)*(IKsin(j30))))+(((-1.0)*cj27*x1127))+((px*sj27)));
evalcond[2]=((0.253041)+(((-1.0)*pp))+(((0.2)*x1128))+(((0.2568)*x1126))+(((0.2)*py*sj27)));
evalcond[3]=((0.1)+(((0.4)*cj28))+(((-1.0)*sj27*x1127))+(((-1.0)*x1128))+((cj28*x1129)));
evalcond[4]=((0.4)+x1129+(((-1.0)*cj28*sj27*x1127))+(((-1.0)*cj28*x1128))+(((0.1)*cj28))+((pz*sj28)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j30]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1135=IKPowWithIntegerCheck(sj29,-1);
if(!x1135.valid){
continue;
}
IkReal x1130=x1135.value;
IkReal x1131=((0.00311526479750779)*x1130);
IkReal x1132=(cj28*cj29);
IkReal x1133=((1000.0)*cj27*py);
IkReal x1134=((1000.0)*px*sj27);
CheckValue<IkReal> x1136=IKPowWithIntegerCheck(sj28,-1);
if(!x1136.valid){
continue;
}
if( IKabs((x1131*((x1133+(((-1.0)*x1134)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1131*(x1136.value)*(((((-400.0)*sj28*sj29))+(((-1000.0)*pz*sj29))+(((-1.0)*x1132*x1133))+((x1132*x1134)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x1131*((x1133+(((-1.0)*x1134))))))+IKsqr((x1131*(x1136.value)*(((((-400.0)*sj28*sj29))+(((-1000.0)*pz*sj29))+(((-1.0)*x1132*x1133))+((x1132*x1134))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2((x1131*((x1133+(((-1.0)*x1134))))), (x1131*(x1136.value)*(((((-400.0)*sj28*sj29))+(((-1000.0)*pz*sj29))+(((-1.0)*x1132*x1133))+((x1132*x1134))))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[6];
IkReal x1137=IKsin(j30);
IkReal x1138=IKcos(j30);
IkReal x1139=((1.0)*py);
IkReal x1140=(cj29*sj28);
IkReal x1141=(cj27*px);
IkReal x1142=(cj28*cj29);
IkReal x1143=(py*sj27);
IkReal x1144=(px*sj27);
IkReal x1145=((0.321)*x1137);
IkReal x1146=((0.321)*x1138);
evalcond[0]=(x1144+((sj29*x1145))+(((-1.0)*cj27*x1139)));
evalcond[1]=((0.253041)+(((-1.0)*pp))+(((0.2568)*x1138))+(((0.2)*x1143))+(((0.2)*x1141)));
evalcond[2]=((((0.4)*sj28))+((x1142*x1145))+((sj28*x1146))+pz);
evalcond[3]=((0.4)+x1146+(((-1.0)*cj28*x1141))+(((0.1)*cj28))+((pz*sj28))+(((-1.0)*cj28*sj27*x1139)));
evalcond[4]=((0.1)+(((-1.0)*x1140*x1145))+(((0.4)*cj28))+(((-1.0)*x1141))+((cj28*x1146))+(((-1.0)*sj27*x1139)));
evalcond[5]=(((x1140*x1143))+((x1140*x1141))+x1145+((pz*x1142))+((sj29*x1144))+(((-0.1)*x1140))+(((-1.0)*cj27*sj29*x1139)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x1147=((250.0)*sj28);
IkReal x1148=(py*sj27);
IkReal x1149=(cj27*px);
CheckValue<IkReal> x1150=IKPowWithIntegerCheck(cj28,-1);
if(!x1150.valid){
continue;
}
CheckValue<IkReal> x1151=IKPowWithIntegerCheck(cj29,-1);
if(!x1151.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1150.value)*(x1151.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+(((-1250.0)*pp*sj28))+((x1147*x1149))+((x1147*x1148)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1148))+(((-0.778816199376947)*x1149)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1150.value)*(x1151.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+(((-1250.0)*pp*sj28))+((x1147*x1149))+((x1147*x1148))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1148))+(((-0.778816199376947)*x1149))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1150.value)*(x1151.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+(((-1250.0)*pp*sj28))+((x1147*x1149))+((x1147*x1148))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1148))+(((-0.778816199376947)*x1149))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[6];
IkReal x1152=IKsin(j30);
IkReal x1153=IKcos(j30);
IkReal x1154=((1.0)*py);
IkReal x1155=(cj29*sj28);
IkReal x1156=(cj27*px);
IkReal x1157=(cj28*cj29);
IkReal x1158=(py*sj27);
IkReal x1159=(px*sj27);
IkReal x1160=((0.321)*x1152);
IkReal x1161=((0.321)*x1153);
evalcond[0]=(x1159+(((-1.0)*cj27*x1154))+((sj29*x1160)));
evalcond[1]=((0.253041)+(((0.2)*x1156))+(((0.2)*x1158))+(((0.2568)*x1153))+(((-1.0)*pp)));
evalcond[2]=((((0.4)*sj28))+((x1157*x1160))+pz+((sj28*x1161)));
evalcond[3]=((0.4)+x1161+(((-1.0)*cj28*sj27*x1154))+(((-1.0)*cj28*x1156))+(((0.1)*cj28))+((pz*sj28)));
evalcond[4]=((0.1)+(((-1.0)*sj27*x1154))+(((0.4)*cj28))+(((-1.0)*x1156))+(((-1.0)*x1155*x1160))+((cj28*x1161)));
evalcond[5]=(((pz*x1157))+x1160+(((-1.0)*cj27*sj29*x1154))+((sj29*x1159))+(((-0.1)*x1155))+((x1155*x1156))+((x1155*x1158)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1162=IKPowWithIntegerCheck(sj29,-1);
if(!x1162.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1162.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1162.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1162.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[6];
IkReal x1163=IKsin(j30);
IkReal x1164=IKcos(j30);
IkReal x1165=((1.0)*py);
IkReal x1166=(cj29*sj28);
IkReal x1167=(cj27*px);
IkReal x1168=(cj28*cj29);
IkReal x1169=(py*sj27);
IkReal x1170=(px*sj27);
IkReal x1171=((0.321)*x1163);
IkReal x1172=((0.321)*x1164);
evalcond[0]=(x1170+(((-1.0)*cj27*x1165))+((sj29*x1171)));
evalcond[1]=((0.253041)+(((0.2568)*x1164))+(((-1.0)*pp))+(((0.2)*x1167))+(((0.2)*x1169)));
evalcond[2]=((((0.4)*sj28))+((x1168*x1171))+pz+((sj28*x1172)));
evalcond[3]=((0.4)+x1172+(((-1.0)*cj28*x1167))+(((0.1)*cj28))+(((-1.0)*cj28*sj27*x1165))+((pz*sj28)));
evalcond[4]=((0.1)+((cj28*x1172))+(((0.4)*cj28))+(((-1.0)*sj27*x1165))+(((-1.0)*x1166*x1171))+(((-1.0)*x1167)));
evalcond[5]=(x1171+((x1166*x1169))+((x1166*x1167))+((pz*x1168))+(((-0.1)*x1166))+(((-1.0)*cj27*sj29*x1165))+((sj29*x1170)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}
    }
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x200=(sj27*sj29);
IkReal x201=(cj27*sj29);
IkReal x202=(cj28*sj29);
IkReal x203=(cj28*cj30);
IkReal x204=((1.0)*sj30);
IkReal x205=((1.0)*cj29);
IkReal x206=(cj29*x204);
IkReal x207=((1.0)*cj30*sj28);
IkReal x208=((((-1.0)*x203*x205))+((sj28*sj30)));
IkReal x209=((((-1.0)*sj27*x205))+((sj28*x201)));
IkReal x210=(((sj28*x200))+((cj27*cj29)));
IkReal x211=(x203+(((-1.0)*sj28*x206)));
IkReal x212=(cj27*x211);
IkReal x213=((((-1.0)*cj30*sj28*x205))+(((-1.0)*cj28*x204)));
IkReal x214=((((-1.0)*x207))+(((-1.0)*cj28*x206)));
IkReal x215=(cj27*x213);
IkReal x216=(((sj27*x211))+((sj30*x201)));
IkReal x217=(x212+(((-1.0)*sj30*x200)));
IkReal x218=(((sj27*x213))+((cj30*x201)));
IkReal x219=(x215+(((-1.0)*cj30*x200)));
new_r00=(((r20*x208))+((r00*((x215+(((-1.0)*cj30*x200))))))+((r10*x218)));
new_r01=(((r11*x218))+((r21*x208))+((r01*x219)));
new_r02=(((r22*x208))+((r12*x218))+((r02*x219)));
new_r10=(((r00*x209))+((r20*x202))+((r10*x210)));
new_r11=(((r01*x209))+((r11*x210))+((r21*x202)));
new_r12=(((r22*x202))+((r12*x210))+((r02*x209)));
new_r20=(((r00*x217))+((r10*x216))+((r20*x214)));
new_r21=(((r21*x214))+((r11*x216))+((r01*x217)));
new_r22=(((r02*(((((-1.0)*x200*x204))+x212))))+((r12*x216))+((r22*x214)));
{
IkReal j32array[2], cj32array[2], sj32array[2];
bool j32valid[2]={false};
_nj32 = 2;
cj32array[0]=new_r22;
if( cj32array[0] >= -1-IKFAST_SINCOS_THRESH && cj32array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j32valid[0] = j32valid[1] = true;
    j32array[0] = IKacos(cj32array[0]);
    sj32array[0] = IKsin(j32array[0]);
    cj32array[1] = cj32array[0];
    j32array[1] = -j32array[0];
    sj32array[1] = -sj32array[0];
}
else if( isnan(cj32array[0]) )
{
    // probably any value will work
    j32valid[0] = true;
    cj32array[0] = 1; sj32array[0] = 0; j32array[0] = 0;
}
for(int ij32 = 0; ij32 < 2; ++ij32)
{
if( !j32valid[ij32] )
{
    continue;
}
_ij32[0] = ij32; _ij32[1] = -1;
for(int iij32 = ij32+1; iij32 < 2; ++iij32)
{
if( j32valid[iij32] && IKabs(cj32array[ij32]-cj32array[iij32]) < IKFAST_SOLUTION_THRESH && IKabs(sj32array[ij32]-sj32array[iij32]) < IKFAST_SOLUTION_THRESH )
{
    j32valid[iij32]=false; _ij32[1] = iij32; break; 
}
}
j32 = j32array[ij32]; cj32 = cj32array[ij32]; sj32 = sj32array[ij32];

{
IkReal j31eval[2];
IkReal x220=(sj27*sj29);
IkReal x221=(cj27*sj29);
IkReal x222=(cj28*sj29);
IkReal x223=(cj28*cj30);
IkReal x224=((1.0)*sj30);
IkReal x225=((1.0)*cj29);
IkReal x226=(cj29*x224);
IkReal x227=((1.0)*cj30*sj28);
IkReal x228=x208;
IkReal x229=x209;
IkReal x230=x210;
IkReal x231=((((-1.0)*sj28*x226))+x223);
IkReal x232=(cj27*x231);
IkReal x233=x213;
IkReal x234=((((-1.0)*cj28*x226))+(((-1.0)*x227)));
IkReal x235=(cj27*x233);
IkReal x236=(((sj30*x221))+((sj27*x231)));
IkReal x237=((((-1.0)*sj30*x220))+x232);
IkReal x238=(((cj30*x221))+((sj27*x233)));
IkReal x239=(x235+(((-1.0)*cj30*x220)));
new_r00=(((r20*x228))+((r10*x238))+((r00*((x235+(((-1.0)*cj30*x220)))))));
new_r01=(((r11*x238))+((r01*x239))+((r21*x228)));
new_r02=(((r02*x239))+((r22*x228))+((r12*x238)));
new_r10=(((r20*x222))+((r00*x229))+((r10*x230)));
new_r11=(((r11*x230))+((r01*x229))+((r21*x222)));
new_r12=(((r02*x229))+((r22*x222))+((r12*x230)));
new_r20=(((r10*x236))+((r00*x237))+((r20*x234)));
new_r21=(((r11*x236))+((r01*x237))+((r21*x234)));
new_r22=(((r02*((x232+(((-1.0)*x220*x224))))))+((r12*x236))+((r22*x234)));
j31eval[0]=sj32;
j31eval[1]=IKsign(sj32);
if( IKabs(j31eval[0]) < 0.0000010000000000  || IKabs(j31eval[1]) < 0.0000010000000000  )
{
{
IkReal j31eval[1];
IkReal x240=(sj27*sj29);
IkReal x241=(cj27*sj29);
IkReal x242=(cj28*sj29);
IkReal x243=(cj28*cj30);
IkReal x244=((1.0)*sj30);
IkReal x245=((1.0)*cj29);
IkReal x246=(cj29*x244);
IkReal x247=((1.0)*cj30*sj28);
IkReal x248=x208;
IkReal x249=x209;
IkReal x250=x210;
IkReal x251=(x243+(((-1.0)*sj28*x246)));
IkReal x252=(cj27*x251);
IkReal x253=x213;
IkReal x254=((((-1.0)*x247))+(((-1.0)*cj28*x246)));
IkReal x255=(cj27*x253);
IkReal x256=(((sj30*x241))+((sj27*x251)));
IkReal x257=((((-1.0)*sj30*x240))+x252);
IkReal x258=(((sj27*x253))+((cj30*x241)));
IkReal x259=((((-1.0)*cj30*x240))+x255);
new_r00=(((r10*x258))+((r00*(((((-1.0)*cj30*x240))+x255))))+((r20*x248)));
new_r01=(((r11*x258))+((r01*x259))+((r21*x248)));
new_r02=(((r22*x248))+((r12*x258))+((r02*x259)));
new_r10=(((r10*x250))+((r00*x249))+((r20*x242)));
new_r11=(((r11*x250))+((r21*x242))+((r01*x249)));
new_r12=(((r02*x249))+((r22*x242))+((r12*x250)));
new_r20=(((r20*x254))+((r00*x257))+((r10*x256)));
new_r21=(((r21*x254))+((r11*x256))+((r01*x257)));
new_r22=(((r12*x256))+((r22*x254))+((r02*((x252+(((-1.0)*x240*x244)))))));
j31eval[0]=sj32;
if( IKabs(j31eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[6];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j31array[2], cj31array[2], sj31array[2];
bool j31valid[2]={false};
_nj31 = 2;
CheckValue<IkReal> x261 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x261.valid){
continue;
}
IkReal x260=x261.value;
j31array[0]=((-1.0)*x260);
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
j31array[1]=((3.14159265358979)+(((-1.0)*x260)));
sj31array[1]=IKsin(j31array[1]);
cj31array[1]=IKcos(j31array[1]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
if( j31array[1] > IKPI )
{
    j31array[1]-=IK2PI;
}
else if( j31array[1] < -IKPI )
{    j31array[1]+=IK2PI;
}
j31valid[1] = true;
for(int ij31 = 0; ij31 < 2; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 2; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[1];
evalcond[0]=(((new_r12*(IKcos(j31))))+(((-1.0)*new_r02*(IKsin(j31)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x262=((1.0)*sj31);
if( IKabs(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x262)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x262))+((cj31*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x262))))+IKsqr(((((-1.0)*new_r01*x262))+((cj31*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x262))), ((((-1.0)*new_r01*x262))+((cj31*new_r00))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x263=IKsin(j33);
IkReal x264=IKcos(j33);
IkReal x265=((1.0)*sj31);
IkReal x266=((1.0)*x264);
IkReal x267=(sj31*x263);
IkReal x268=((1.0)*x263);
IkReal x269=(cj31*x266);
evalcond[0]=(((cj31*new_r01))+((new_r11*sj31))+x263);
evalcond[1]=(((sj31*x264))+((cj31*x263))+new_r01);
evalcond[2]=(((cj31*new_r00))+((new_r10*sj31))+(((-1.0)*x266)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x265))+(((-1.0)*x268)));
evalcond[4]=((((-1.0)*new_r01*x265))+((cj31*new_r11))+(((-1.0)*x266)));
evalcond[5]=(x267+new_r00+(((-1.0)*x269)));
evalcond[6]=(x267+new_r11+(((-1.0)*x269)));
evalcond[7]=((((-1.0)*cj31*x268))+new_r10+(((-1.0)*x264*x265)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j31array[2], cj31array[2], sj31array[2];
bool j31valid[2]={false};
_nj31 = 2;
CheckValue<IkReal> x271 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x271.valid){
continue;
}
IkReal x270=x271.value;
j31array[0]=((-1.0)*x270);
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
j31array[1]=((3.14159265358979)+(((-1.0)*x270)));
sj31array[1]=IKsin(j31array[1]);
cj31array[1]=IKcos(j31array[1]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
if( j31array[1] > IKPI )
{
    j31array[1]-=IK2PI;
}
else if( j31array[1] < -IKPI )
{    j31array[1]+=IK2PI;
}
j31valid[1] = true;
for(int ij31 = 0; ij31 < 2; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 2; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[1];
evalcond[0]=(((new_r12*(IKcos(j31))))+(((-1.0)*new_r02*(IKsin(j31)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x272=((1.0)*sj31);
if( IKabs((((cj31*new_r01))+(((-1.0)*new_r00*x272)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj31*new_r00))+(((-1.0)*new_r01*x272)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj31*new_r01))+(((-1.0)*new_r00*x272))))+IKsqr(((((-1.0)*cj31*new_r00))+(((-1.0)*new_r01*x272))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((((cj31*new_r01))+(((-1.0)*new_r00*x272))), ((((-1.0)*cj31*new_r00))+(((-1.0)*new_r01*x272))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x273=IKsin(j33);
IkReal x274=IKcos(j33);
IkReal x275=((1.0)*sj31);
IkReal x276=((1.0)*x273);
IkReal x277=(sj31*x274);
IkReal x278=((1.0)*x274);
IkReal x279=(cj31*x276);
evalcond[0]=(((cj31*new_r00))+((new_r10*sj31))+x274);
evalcond[1]=(((cj31*new_r01))+((new_r11*sj31))+(((-1.0)*x276)));
evalcond[2]=(((sj31*x273))+((cj31*x274))+new_r00);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x275))+(((-1.0)*x276)));
evalcond[4]=((((-1.0)*new_r01*x275))+((cj31*new_r11))+(((-1.0)*x278)));
evalcond[5]=(x277+(((-1.0)*x279))+new_r01);
evalcond[6]=(x277+(((-1.0)*x279))+new_r10);
evalcond[7]=((((-1.0)*x273*x275))+(((-1.0)*cj31*x278))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j31, j33]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
CheckValue<IkReal> x281=IKPowWithIntegerCheck(sj32,-1);
if(!x281.valid){
continue;
}
IkReal x280=x281.value;
CheckValue<IkReal> x282=IKPowWithIntegerCheck(new_r12,-1);
if(!x282.valid){
continue;
}
if( IKabs((x280*(x282.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj32*cj32))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x280)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x280*(x282.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj32*cj32)))))))+IKsqr((new_r02*x280))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j31array[0]=IKatan2((x280*(x282.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj32*cj32)))))), (new_r02*x280));
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[8];
IkReal x283=IKcos(j31);
IkReal x284=IKsin(j31);
IkReal x285=((1.0)*sj32);
IkReal x286=(new_r02*x283);
IkReal x287=(new_r12*x284);
IkReal x288=(sj32*x283);
IkReal x289=(sj32*x284);
evalcond[0]=(new_r02+(((-1.0)*x283*x285)));
evalcond[1]=((((-1.0)*x284*x285))+new_r12);
evalcond[2]=(((new_r12*x283))+(((-1.0)*new_r02*x284)));
evalcond[3]=(x287+x286+(((-1.0)*x285)));
evalcond[4]=(((cj32*new_r20))+((new_r00*x288))+((new_r10*x289)));
evalcond[5]=(((cj32*new_r21))+((new_r11*x289))+((new_r01*x288)));
evalcond[6]=((-1.0)+((cj32*new_r22))+((sj32*x287))+((sj32*x286)));
evalcond[7]=((((-1.0)*new_r22*x285))+((cj32*x287))+((cj32*x286)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j33eval[2];
IkReal x290=(sj27*sj29);
IkReal x291=(cj27*sj29);
IkReal x292=(cj28*sj29);
IkReal x293=(cj28*cj30);
IkReal x294=((1.0)*sj30);
IkReal x295=((1.0)*cj29);
IkReal x296=(cj29*x294);
IkReal x297=((1.0)*cj30*sj28);
IkReal x298=x208;
IkReal x299=x209;
IkReal x300=x210;
IkReal x301=((((-1.0)*sj28*x296))+x293);
IkReal x302=(cj27*x301);
IkReal x303=x213;
IkReal x304=((((-1.0)*x297))+(((-1.0)*cj28*x296)));
IkReal x305=(cj27*x303);
IkReal x306=(((sj27*x301))+((sj30*x291)));
IkReal x307=(x302+(((-1.0)*sj30*x290)));
IkReal x308=(((cj30*x291))+((sj27*x303)));
IkReal x309=(x305+(((-1.0)*cj30*x290)));
new_r00=(((r00*((x305+(((-1.0)*cj30*x290))))))+((r20*x298))+((r10*x308)));
new_r01=(((r11*x308))+((r01*x309))+((r21*x298)));
new_r02=(((r02*x309))+((r22*x298))+((r12*x308)));
new_r10=(((r20*x292))+((r00*x299))+((r10*x300)));
new_r11=(((r11*x300))+((r01*x299))+((r21*x292)));
new_r12=(((r02*x299))+((r22*x292))+((r12*x300)));
new_r20=(((r20*x304))+((r10*x306))+((r00*x307)));
new_r21=(((r11*x306))+((r21*x304))+((r01*x307)));
new_r22=(((r22*x304))+((r02*(((((-1.0)*x290*x294))+x302))))+((r12*x306)));
j33eval[0]=sj32;
j33eval[1]=IKsign(sj32);
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  )
{
{
IkReal j33eval[2];
IkReal x310=(sj27*sj29);
IkReal x311=(cj27*sj29);
IkReal x312=(cj28*sj29);
IkReal x313=(cj28*cj30);
IkReal x314=((1.0)*sj30);
IkReal x315=((1.0)*cj29);
IkReal x316=(cj29*x314);
IkReal x317=((1.0)*cj30*sj28);
IkReal x318=x208;
IkReal x319=x209;
IkReal x320=x210;
IkReal x321=(x313+(((-1.0)*sj28*x316)));
IkReal x322=(cj27*x321);
IkReal x323=x213;
IkReal x324=((((-1.0)*cj28*x316))+(((-1.0)*x317)));
IkReal x325=(cj27*x323);
IkReal x326=(((sj30*x311))+((sj27*x321)));
IkReal x327=(x322+(((-1.0)*sj30*x310)));
IkReal x328=(((cj30*x311))+((sj27*x323)));
IkReal x329=((((-1.0)*cj30*x310))+x325);
new_r00=(((r20*x318))+((r00*(((((-1.0)*cj30*x310))+x325))))+((r10*x328)));
new_r01=(((r11*x328))+((r01*x329))+((r21*x318)));
new_r02=(((r02*x329))+((r12*x328))+((r22*x318)));
new_r10=(((r20*x312))+((r10*x320))+((r00*x319)));
new_r11=(((r11*x320))+((r01*x319))+((r21*x312)));
new_r12=(((r02*x319))+((r12*x320))+((r22*x312)));
new_r20=(((r20*x324))+((r00*x327))+((r10*x326)));
new_r21=(((r21*x324))+((r11*x326))+((r01*x327)));
new_r22=(((r02*(((((-1.0)*x310*x314))+x322))))+((r12*x326))+((r22*x324)));
j33eval[0]=sj31;
j33eval[1]=sj32;
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  )
{
{
IkReal j33eval[3];
IkReal x330=(sj27*sj29);
IkReal x331=(cj27*sj29);
IkReal x332=(cj28*sj29);
IkReal x333=(cj28*cj30);
IkReal x334=((1.0)*sj30);
IkReal x335=((1.0)*cj29);
IkReal x336=(cj29*x334);
IkReal x337=((1.0)*cj30*sj28);
IkReal x338=x208;
IkReal x339=x209;
IkReal x340=x210;
IkReal x341=((((-1.0)*sj28*x336))+x333);
IkReal x342=(cj27*x341);
IkReal x343=x213;
IkReal x344=((((-1.0)*cj28*x336))+(((-1.0)*x337)));
IkReal x345=(cj27*x343);
IkReal x346=(((sj30*x331))+((sj27*x341)));
IkReal x347=(x342+(((-1.0)*sj30*x330)));
IkReal x348=(((sj27*x343))+((cj30*x331)));
IkReal x349=(x345+(((-1.0)*cj30*x330)));
new_r00=(((r00*((x345+(((-1.0)*cj30*x330))))))+((r20*x338))+((r10*x348)));
new_r01=(((r01*x349))+((r21*x338))+((r11*x348)));
new_r02=(((r22*x338))+((r02*x349))+((r12*x348)));
new_r10=(((r00*x339))+((r20*x332))+((r10*x340)));
new_r11=(((r01*x339))+((r21*x332))+((r11*x340)));
new_r12=(((r22*x332))+((r02*x339))+((r12*x340)));
new_r20=(((r00*x347))+((r20*x344))+((r10*x346)));
new_r21=(((r01*x347))+((r21*x344))+((r11*x346)));
new_r22=(((r22*x344))+((r02*((x342+(((-1.0)*x330*x334))))))+((r12*x346)));
j33eval[0]=cj31;
j33eval[1]=cj32;
j33eval[2]=sj32;
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  || IKabs(j33eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[12];
bool bgotonextstatement = true;
do
{
IkReal x350=((((-1.0)*cj32))+new_r22);
IkReal x351=((((-1.0)*sj32))+new_r12);
IkReal x352=((1.0)*sj32);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j31)))), 6.28318530717959)));
evalcond[1]=x350;
evalcond[2]=x350;
evalcond[3]=new_r02;
evalcond[4]=x351;
evalcond[5]=x351;
evalcond[6]=(((new_r10*sj32))+((cj32*new_r20)));
evalcond[7]=(((new_r11*sj32))+((cj32*new_r21)));
evalcond[8]=((-1.0)+((new_r12*sj32))+((cj32*new_r22)));
evalcond[9]=((((-1.0)*new_r22*x352))+((cj32*new_r12)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x353 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x353.valid){
continue;
}
CheckValue<IkReal> x354=IKPowWithIntegerCheck(IKsign(new_r12),-1);
if(!x354.valid){
continue;
}
j33array[0]=((-1.5707963267949)+(x353.value)+(((1.5707963267949)*(x354.value))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x355=IKsin(j33);
IkReal x356=IKcos(j33);
IkReal x357=((1.0)*new_r12);
IkReal x358=((1.0)*x356);
IkReal x359=((1.0)*x355);
evalcond[0]=(new_r20+((new_r12*x356)));
evalcond[1]=(((new_r22*x355))+new_r11);
evalcond[2]=(new_r21+(((-1.0)*x355*x357)));
evalcond[3]=((((-1.0)*new_r22*x358))+new_r10);
evalcond[4]=((((-1.0)*x359))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x358))+(((-1.0)*new_r01)));
evalcond[6]=(x355+((new_r11*new_r22))+(((-1.0)*new_r21*x357)));
evalcond[7]=((((-1.0)*x358))+((new_r10*new_r22))+(((-1.0)*new_r20*x357)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x360=((((-1.0)*cj32))+new_r22);
IkReal x361=((1.0)*sj32);
IkReal x362=((1.0)*new_r12);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j31)))), 6.28318530717959)));
evalcond[1]=x360;
evalcond[2]=x360;
evalcond[3]=new_r02;
evalcond[4]=(sj32+new_r12);
evalcond[5]=((((-1.0)*x362))+(((-1.0)*x361)));
evalcond[6]=((((-1.0)*new_r10*x361))+((cj32*new_r20)));
evalcond[7]=((((-1.0)*new_r11*x361))+((cj32*new_r21)));
evalcond[8]=((-1.0)+(((-1.0)*new_r12*x361))+((cj32*new_r22)));
evalcond[9]=((((-1.0)*cj32*x362))+(((-1.0)*new_r22*x361)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r00, new_r01);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x363=IKsin(j33);
IkReal x364=IKcos(j33);
IkReal x365=((1.0)*new_r10);
IkReal x366=((1.0)*new_r11);
IkReal x367=((1.0)*x364);
evalcond[0]=(new_r21+((new_r12*x363)));
evalcond[1]=((((-1.0)*x363))+new_r00);
evalcond[2]=((((-1.0)*x367))+new_r01);
evalcond[3]=((((-1.0)*new_r12*x367))+new_r20);
evalcond[4]=(((new_r22*x363))+(((-1.0)*x366)));
evalcond[5]=((((-1.0)*x365))+(((-1.0)*new_r22*x367)));
evalcond[6]=((((-1.0)*new_r22*x366))+x363+((new_r12*new_r21)));
evalcond[7]=((((-1.0)*x367))+(((-1.0)*new_r22*x365))+((new_r12*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x368=((1.0)*sj31);
IkReal x369=(((cj31*new_r12))+(((-1.0)*new_r02*x368)));
IkReal x370=(((cj31*new_r00))+((new_r10*sj31)));
IkReal x371=(((cj31*new_r01))+((new_r11*sj31)));
IkReal x372=((-1.0)+((cj31*new_r02))+((new_r12*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j32)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=((((-1.0)*cj31))+new_r02);
evalcond[3]=((((-1.0)*x368))+new_r12);
evalcond[4]=x369;
evalcond[5]=x369;
evalcond[6]=x372;
evalcond[7]=x371;
evalcond[8]=x370;
evalcond[9]=x370;
evalcond[10]=x371;
evalcond[11]=x372;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x373=IKcos(j33);
IkReal x374=IKsin(j33);
IkReal x375=((1.0)*new_r12);
IkReal x376=((1.0)*x374);
IkReal x377=((1.0)*x373);
evalcond[0]=(x373+new_r20);
evalcond[1]=((((-1.0)*x376))+new_r21);
evalcond[2]=(((new_r12*x373))+new_r01);
evalcond[3]=(((new_r12*x374))+new_r00);
evalcond[4]=(new_r11+(((-1.0)*new_r02*x377)));
evalcond[5]=(new_r10+(((-1.0)*new_r02*x376)));
evalcond[6]=((((-1.0)*new_r00*x375))+(((-1.0)*x376))+((new_r02*new_r10)));
evalcond[7]=((((-1.0)*x377))+((new_r02*new_r11))+(((-1.0)*new_r01*x375)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x378=(new_r10*sj31);
IkReal x379=(cj31*new_r00);
IkReal x380=(cj31*new_r02);
IkReal x381=(new_r11*sj31);
IkReal x382=(new_r12*sj31);
IkReal x383=(cj31*new_r01);
IkReal x384=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j32)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=(cj31+new_r02);
evalcond[3]=(sj31+new_r12);
evalcond[4]=x384;
evalcond[5]=x384;
evalcond[6]=((1.0)+x382+x380);
evalcond[7]=(x383+x381);
evalcond[8]=(x379+x378);
evalcond[9]=((((-1.0)*x378))+(((-1.0)*x379)));
evalcond[10]=((((-1.0)*x381))+(((-1.0)*x383)));
evalcond[11]=((-1.0)+(((-1.0)*x380))+(((-1.0)*x382)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x385=IKcos(j33);
IkReal x386=IKsin(j33);
IkReal x387=((1.0)*new_r02);
IkReal x388=((1.0)*x385);
IkReal x389=((1.0)*x386);
evalcond[0]=(x386+new_r21);
evalcond[1]=((((-1.0)*x388))+new_r20);
evalcond[2]=(((new_r02*x385))+new_r11);
evalcond[3]=(((new_r02*x386))+new_r10);
evalcond[4]=((((-1.0)*new_r12*x388))+new_r01);
evalcond[5]=((((-1.0)*new_r12*x389))+new_r00);
evalcond[6]=((((-1.0)*new_r10*x387))+((new_r00*new_r12))+(((-1.0)*x389)));
evalcond[7]=((((-1.0)*new_r11*x387))+((new_r01*new_r12))+(((-1.0)*x388)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x390=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
IkReal x391=(((cj31*new_r02))+((new_r12*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x390;
evalcond[7]=x390;
evalcond[8]=x391;
evalcond[9]=x391;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x392=((1.0)*sj31);
if( IKabs(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x392)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x392))+((cj31*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x392))))+IKsqr(((((-1.0)*new_r01*x392))+((cj31*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x392))), ((((-1.0)*new_r01*x392))+((cj31*new_r00))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x393=IKsin(j33);
IkReal x394=IKcos(j33);
IkReal x395=((1.0)*sj31);
IkReal x396=((1.0)*x394);
IkReal x397=(sj31*x393);
IkReal x398=((1.0)*x393);
IkReal x399=(cj31*x396);
evalcond[0]=(((cj31*new_r01))+((new_r11*sj31))+x393);
evalcond[1]=(((cj31*x393))+((sj31*x394))+new_r01);
evalcond[2]=((((-1.0)*x396))+((cj31*new_r00))+((new_r10*sj31)));
evalcond[3]=((((-1.0)*x398))+((cj31*new_r10))+(((-1.0)*new_r00*x395)));
evalcond[4]=((((-1.0)*new_r01*x395))+(((-1.0)*x396))+((cj31*new_r11)));
evalcond[5]=((((-1.0)*x399))+x397+new_r00);
evalcond[6]=((((-1.0)*x399))+x397+new_r11);
evalcond[7]=((((-1.0)*x394*x395))+(((-1.0)*cj31*x398))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x400=(cj31*new_r02);
IkReal x401=(new_r12*sj31);
IkReal x402=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x402;
evalcond[7]=x402;
evalcond[8]=(x401+x400);
evalcond[9]=((((-1.0)*x401))+(((-1.0)*x400)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x403=((1.0)*sj31);
if( IKabs((((cj31*new_r01))+(((-1.0)*new_r00*x403)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj31*new_r00))+(((-1.0)*new_r01*x403)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj31*new_r01))+(((-1.0)*new_r00*x403))))+IKsqr(((((-1.0)*cj31*new_r00))+(((-1.0)*new_r01*x403))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((((cj31*new_r01))+(((-1.0)*new_r00*x403))), ((((-1.0)*cj31*new_r00))+(((-1.0)*new_r01*x403))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x404=IKsin(j33);
IkReal x405=IKcos(j33);
IkReal x406=((1.0)*sj31);
IkReal x407=((1.0)*x404);
IkReal x408=(sj31*x405);
IkReal x409=((1.0)*x405);
IkReal x410=(cj31*x407);
evalcond[0]=(((cj31*new_r00))+((new_r10*sj31))+x405);
evalcond[1]=(((cj31*new_r01))+((new_r11*sj31))+(((-1.0)*x407)));
evalcond[2]=(((sj31*x404))+((cj31*x405))+new_r00);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x406))+(((-1.0)*x407)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*new_r01*x406))+(((-1.0)*x409)));
evalcond[5]=(x408+new_r01+(((-1.0)*x410)));
evalcond[6]=(x408+new_r10+(((-1.0)*x410)));
evalcond[7]=((((-1.0)*cj31*x409))+(((-1.0)*x404*x406))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x411=((((-1.0)*cj32))+new_r22);
IkReal x412=((((-1.0)*sj32))+new_r02);
IkReal x413=((1.0)*sj32);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j31))), 6.28318530717959)));
evalcond[1]=x411;
evalcond[2]=x411;
evalcond[3]=x412;
evalcond[4]=new_r12;
evalcond[5]=x412;
evalcond[6]=(((new_r00*sj32))+((cj32*new_r20)));
evalcond[7]=(((new_r01*sj32))+((cj32*new_r21)));
evalcond[8]=((-1.0)+((new_r02*sj32))+((cj32*new_r22)));
evalcond[9]=(((cj32*new_r02))+(((-1.0)*new_r22*x413)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r10, new_r11);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x414=IKcos(j33);
IkReal x415=IKsin(j33);
IkReal x416=((1.0)*new_r02);
IkReal x417=((1.0)*x414);
evalcond[0]=(new_r20+((new_r02*x414)));
evalcond[1]=(new_r10+(((-1.0)*x415)));
evalcond[2]=(new_r11+(((-1.0)*x417)));
evalcond[3]=(((new_r22*x415))+new_r01);
evalcond[4]=((((-1.0)*x415*x416))+new_r21);
evalcond[5]=(new_r00+(((-1.0)*new_r22*x417)));
evalcond[6]=(((new_r01*new_r22))+x415+(((-1.0)*new_r21*x416)));
evalcond[7]=(((new_r00*new_r22))+(((-1.0)*new_r20*x416))+(((-1.0)*x417)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x418=((((-1.0)*cj32))+new_r22);
IkReal x419=((1.0)*sj32);
IkReal x420=((1.0)*new_r02);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j31)))), 6.28318530717959)));
evalcond[1]=x418;
evalcond[2]=x418;
evalcond[3]=(sj32+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((((-1.0)*x420))+(((-1.0)*x419)));
evalcond[6]=(((cj32*new_r20))+(((-1.0)*new_r00*x419)));
evalcond[7]=(((cj32*new_r21))+(((-1.0)*new_r01*x419)));
evalcond[8]=((-1.0)+((cj32*new_r22))+(((-1.0)*new_r02*x419)));
evalcond[9]=((((-1.0)*new_r22*x419))+(((-1.0)*cj32*x420)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x421 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),new_r20,IKFAST_ATAN2_MAGTHRESH);
if(!x421.valid){
continue;
}
CheckValue<IkReal> x422=IKPowWithIntegerCheck(IKsign(new_r02),-1);
if(!x422.valid){
continue;
}
j33array[0]=((-1.5707963267949)+(x421.value)+(((1.5707963267949)*(x422.value))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x423=IKsin(j33);
IkReal x424=IKcos(j33);
IkReal x425=((1.0)*new_r22);
IkReal x426=((1.0)*x424);
evalcond[0]=(new_r21+((new_r02*x423)));
evalcond[1]=((((-1.0)*new_r02*x426))+new_r20);
evalcond[2]=((((-1.0)*x423))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x426))+(((-1.0)*new_r11)));
evalcond[4]=(((new_r22*x423))+(((-1.0)*new_r01)));
evalcond[5]=((((-1.0)*x424*x425))+(((-1.0)*new_r00)));
evalcond[6]=(x423+((new_r02*new_r21))+(((-1.0)*new_r01*x425)));
evalcond[7]=((((-1.0)*new_r00*x425))+(((-1.0)*x426))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j33]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x428=IKPowWithIntegerCheck(sj32,-1);
if(!x428.valid){
continue;
}
IkReal x427=x428.value;
CheckValue<IkReal> x429=IKPowWithIntegerCheck(cj31,-1);
if(!x429.valid){
continue;
}
CheckValue<IkReal> x430=IKPowWithIntegerCheck(cj32,-1);
if(!x430.valid){
continue;
}
if( IKabs((x427*(x429.value)*(x430.value)*((((new_r20*sj31))+(((-1.0)*new_r01*sj32)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x427)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x427*(x429.value)*(x430.value)*((((new_r20*sj31))+(((-1.0)*new_r01*sj32))))))+IKsqr(((-1.0)*new_r20*x427))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((x427*(x429.value)*(x430.value)*((((new_r20*sj31))+(((-1.0)*new_r01*sj32))))), ((-1.0)*new_r20*x427));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x431=IKsin(j33);
IkReal x432=IKcos(j33);
IkReal x433=(cj31*cj32);
IkReal x434=((1.0)*sj31);
IkReal x435=(new_r11*sj31);
IkReal x436=(new_r10*sj31);
IkReal x437=((1.0)*sj32);
IkReal x438=((1.0)*x432);
IkReal x439=((1.0)*x431);
IkReal x440=(sj31*x431);
evalcond[0]=(((sj32*x432))+new_r20);
evalcond[1]=((((-1.0)*x431*x437))+new_r21);
evalcond[2]=(((cj31*new_r01))+((cj32*x431))+x435);
evalcond[3]=((((-1.0)*new_r00*x434))+(((-1.0)*x439))+((cj31*new_r10)));
evalcond[4]=((((-1.0)*x438))+(((-1.0)*new_r01*x434))+((cj31*new_r11)));
evalcond[5]=(((sj31*x432))+((x431*x433))+new_r01);
evalcond[6]=(((cj31*new_r00))+x436+(((-1.0)*cj32*x438)));
evalcond[7]=((((-1.0)*x433*x438))+x440+new_r00);
evalcond[8]=(((cj32*x440))+(((-1.0)*cj31*x438))+new_r11);
evalcond[9]=((((-1.0)*cj31*x439))+new_r10+(((-1.0)*cj32*x432*x434)));
evalcond[10]=(((new_r01*x433))+((cj32*x435))+x431+(((-1.0)*new_r21*x437)));
evalcond[11]=((((-1.0)*x438))+((new_r00*x433))+((cj32*x436))+(((-1.0)*new_r20*x437)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x442=IKPowWithIntegerCheck(sj32,-1);
if(!x442.valid){
continue;
}
IkReal x441=x442.value;
CheckValue<IkReal> x443=IKPowWithIntegerCheck(sj31,-1);
if(!x443.valid){
continue;
}
if( IKabs((x441*(x443.value)*(((((-1.0)*new_r00*sj32))+(((-1.0)*cj31*cj32*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x441)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x441*(x443.value)*(((((-1.0)*new_r00*sj32))+(((-1.0)*cj31*cj32*new_r20))))))+IKsqr(((-1.0)*new_r20*x441))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((x441*(x443.value)*(((((-1.0)*new_r00*sj32))+(((-1.0)*cj31*cj32*new_r20))))), ((-1.0)*new_r20*x441));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x444=IKsin(j33);
IkReal x445=IKcos(j33);
IkReal x446=(cj31*cj32);
IkReal x447=((1.0)*sj31);
IkReal x448=(new_r11*sj31);
IkReal x449=(new_r10*sj31);
IkReal x450=((1.0)*sj32);
IkReal x451=((1.0)*x445);
IkReal x452=((1.0)*x444);
IkReal x453=(sj31*x444);
evalcond[0]=(((sj32*x445))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x444*x450)));
evalcond[2]=(((cj31*new_r01))+((cj32*x444))+x448);
evalcond[3]=((((-1.0)*new_r00*x447))+((cj31*new_r10))+(((-1.0)*x452)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*new_r01*x447))+(((-1.0)*x451)));
evalcond[5]=(((x444*x446))+((sj31*x445))+new_r01);
evalcond[6]=((((-1.0)*cj32*x451))+((cj31*new_r00))+x449);
evalcond[7]=((((-1.0)*x446*x451))+x453+new_r00);
evalcond[8]=(new_r11+((cj32*x453))+(((-1.0)*cj31*x451)));
evalcond[9]=(new_r10+(((-1.0)*cj31*x452))+(((-1.0)*cj32*x445*x447)));
evalcond[10]=((((-1.0)*new_r21*x450))+((new_r01*x446))+((cj32*x448))+x444);
evalcond[11]=(((new_r00*x446))+(((-1.0)*new_r20*x450))+((cj32*x449))+(((-1.0)*x451)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x454=IKPowWithIntegerCheck(IKsign(sj32),-1);
if(!x454.valid){
continue;
}
CheckValue<IkReal> x455 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x455.valid){
continue;
}
j33array[0]=((-1.5707963267949)+(((1.5707963267949)*(x454.value)))+(x455.value));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x456=IKsin(j33);
IkReal x457=IKcos(j33);
IkReal x458=(cj31*cj32);
IkReal x459=((1.0)*sj31);
IkReal x460=(new_r11*sj31);
IkReal x461=(new_r10*sj31);
IkReal x462=((1.0)*sj32);
IkReal x463=((1.0)*x457);
IkReal x464=((1.0)*x456);
IkReal x465=(sj31*x456);
evalcond[0]=(((sj32*x457))+new_r20);
evalcond[1]=((((-1.0)*x456*x462))+new_r21);
evalcond[2]=(((cj31*new_r01))+x460+((cj32*x456)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x464))+(((-1.0)*new_r00*x459)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*new_r01*x459))+(((-1.0)*x463)));
evalcond[5]=(new_r01+((x456*x458))+((sj31*x457)));
evalcond[6]=(((cj31*new_r00))+(((-1.0)*cj32*x463))+x461);
evalcond[7]=(x465+(((-1.0)*x458*x463))+new_r00);
evalcond[8]=(new_r11+((cj32*x465))+(((-1.0)*cj31*x463)));
evalcond[9]=((((-1.0)*cj32*x457*x459))+new_r10+(((-1.0)*cj31*x464)));
evalcond[10]=((((-1.0)*new_r21*x462))+((new_r01*x458))+x456+((cj32*x460)));
evalcond[11]=(((new_r00*x458))+(((-1.0)*new_r20*x462))+(((-1.0)*x463))+((cj32*x461)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
CheckValue<IkReal> x466=IKPowWithIntegerCheck(IKsign(sj32),-1);
if(!x466.valid){
continue;
}
CheckValue<IkReal> x467 = IKatan2WithCheck(IkReal(new_r12),new_r02,IKFAST_ATAN2_MAGTHRESH);
if(!x467.valid){
continue;
}
j31array[0]=((-1.5707963267949)+(((1.5707963267949)*(x466.value)))+(x467.value));
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[8];
IkReal x468=IKcos(j31);
IkReal x469=IKsin(j31);
IkReal x470=((1.0)*sj32);
IkReal x471=(new_r02*x468);
IkReal x472=(new_r12*x469);
IkReal x473=(sj32*x468);
IkReal x474=(sj32*x469);
evalcond[0]=((((-1.0)*x468*x470))+new_r02);
evalcond[1]=((((-1.0)*x469*x470))+new_r12);
evalcond[2]=(((new_r12*x468))+(((-1.0)*new_r02*x469)));
evalcond[3]=((((-1.0)*x470))+x471+x472);
evalcond[4]=(((new_r10*x474))+((new_r00*x473))+((cj32*new_r20)));
evalcond[5]=(((new_r01*x473))+((new_r11*x474))+((cj32*new_r21)));
evalcond[6]=((-1.0)+((sj32*x471))+((sj32*x472))+((cj32*new_r22)));
evalcond[7]=((((-1.0)*new_r22*x470))+((cj32*x471))+((cj32*x472)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j33eval[2];
IkReal x475=(sj27*sj29);
IkReal x476=(cj27*sj29);
IkReal x477=(cj28*sj29);
IkReal x478=(cj28*cj30);
IkReal x479=((1.0)*sj30);
IkReal x480=((1.0)*cj29);
IkReal x481=(cj29*x479);
IkReal x482=((1.0)*cj30*sj28);
IkReal x483=x208;
IkReal x484=x209;
IkReal x485=x210;
IkReal x486=((((-1.0)*sj28*x481))+x478);
IkReal x487=(cj27*x486);
IkReal x488=x213;
IkReal x489=((((-1.0)*x482))+(((-1.0)*cj28*x481)));
IkReal x490=(cj27*x488);
IkReal x491=(((sj27*x486))+((sj30*x476)));
IkReal x492=((((-1.0)*sj30*x475))+x487);
IkReal x493=(((sj27*x488))+((cj30*x476)));
IkReal x494=(x490+(((-1.0)*cj30*x475)));
new_r00=(((r20*x483))+((r00*((x490+(((-1.0)*cj30*x475))))))+((r10*x493)));
new_r01=(((r11*x493))+((r21*x483))+((r01*x494)));
new_r02=(((r02*x494))+((r12*x493))+((r22*x483)));
new_r10=(((r20*x477))+((r10*x485))+((r00*x484)));
new_r11=(((r21*x477))+((r11*x485))+((r01*x484)));
new_r12=(((r02*x484))+((r12*x485))+((r22*x477)));
new_r20=(((r20*x489))+((r10*x491))+((r00*x492)));
new_r21=(((r11*x491))+((r21*x489))+((r01*x492)));
new_r22=(((r02*(((((-1.0)*x475*x479))+x487))))+((r12*x491))+((r22*x489)));
j33eval[0]=sj32;
j33eval[1]=IKsign(sj32);
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  )
{
{
IkReal j33eval[2];
IkReal x495=(sj27*sj29);
IkReal x496=(cj27*sj29);
IkReal x497=(cj28*sj29);
IkReal x498=(cj28*cj30);
IkReal x499=((1.0)*sj30);
IkReal x500=((1.0)*cj29);
IkReal x501=(cj29*x499);
IkReal x502=((1.0)*cj30*sj28);
IkReal x503=x208;
IkReal x504=x209;
IkReal x505=x210;
IkReal x506=((((-1.0)*sj28*x501))+x498);
IkReal x507=(cj27*x506);
IkReal x508=x213;
IkReal x509=((((-1.0)*x502))+(((-1.0)*cj28*x501)));
IkReal x510=(cj27*x508);
IkReal x511=(((sj27*x506))+((sj30*x496)));
IkReal x512=((((-1.0)*sj30*x495))+x507);
IkReal x513=(((sj27*x508))+((cj30*x496)));
IkReal x514=((((-1.0)*cj30*x495))+x510);
new_r00=(((r00*(((((-1.0)*cj30*x495))+x510))))+((r20*x503))+((r10*x513)));
new_r01=(((r01*x514))+((r11*x513))+((r21*x503)));
new_r02=(((r22*x503))+((r02*x514))+((r12*x513)));
new_r10=(((r10*x505))+((r00*x504))+((r20*x497)));
new_r11=(((r01*x504))+((r11*x505))+((r21*x497)));
new_r12=(((r22*x497))+((r12*x505))+((r02*x504)));
new_r20=(((r20*x509))+((r10*x511))+((r00*x512)));
new_r21=(((r01*x512))+((r11*x511))+((r21*x509)));
new_r22=(((r02*(((((-1.0)*x495*x499))+x507))))+((r22*x509))+((r12*x511)));
j33eval[0]=sj31;
j33eval[1]=sj32;
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  )
{
{
IkReal j33eval[3];
IkReal x515=(sj27*sj29);
IkReal x516=(cj27*sj29);
IkReal x517=(cj28*sj29);
IkReal x518=(cj28*cj30);
IkReal x519=((1.0)*sj30);
IkReal x520=((1.0)*cj29);
IkReal x521=(cj29*x519);
IkReal x522=((1.0)*cj30*sj28);
IkReal x523=x208;
IkReal x524=x209;
IkReal x525=x210;
IkReal x526=((((-1.0)*sj28*x521))+x518);
IkReal x527=(cj27*x526);
IkReal x528=x213;
IkReal x529=((((-1.0)*x522))+(((-1.0)*cj28*x521)));
IkReal x530=(cj27*x528);
IkReal x531=(((sj27*x526))+((sj30*x516)));
IkReal x532=((((-1.0)*sj30*x515))+x527);
IkReal x533=(((cj30*x516))+((sj27*x528)));
IkReal x534=((((-1.0)*cj30*x515))+x530);
new_r00=(((r20*x523))+((r10*x533))+((r00*(((((-1.0)*cj30*x515))+x530)))));
new_r01=(((r21*x523))+((r11*x533))+((r01*x534)));
new_r02=(((r02*x534))+((r12*x533))+((r22*x523)));
new_r10=(((r20*x517))+((r10*x525))+((r00*x524)));
new_r11=(((r11*x525))+((r21*x517))+((r01*x524)));
new_r12=(((r02*x524))+((r12*x525))+((r22*x517)));
new_r20=(((r20*x529))+((r10*x531))+((r00*x532)));
new_r21=(((r21*x529))+((r11*x531))+((r01*x532)));
new_r22=(((r12*x531))+((r22*x529))+((r02*(((((-1.0)*x515*x519))+x527)))));
j33eval[0]=cj31;
j33eval[1]=cj32;
j33eval[2]=sj32;
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  || IKabs(j33eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[12];
bool bgotonextstatement = true;
do
{
IkReal x535=((((-1.0)*cj32))+new_r22);
IkReal x536=((((-1.0)*sj32))+new_r12);
IkReal x537=((1.0)*sj32);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j31)))), 6.28318530717959)));
evalcond[1]=x535;
evalcond[2]=x535;
evalcond[3]=new_r02;
evalcond[4]=x536;
evalcond[5]=x536;
evalcond[6]=(((new_r10*sj32))+((cj32*new_r20)));
evalcond[7]=(((new_r11*sj32))+((cj32*new_r21)));
evalcond[8]=((-1.0)+((new_r12*sj32))+((cj32*new_r22)));
evalcond[9]=((((-1.0)*new_r22*x537))+((cj32*new_r12)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x538 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x538.valid){
continue;
}
CheckValue<IkReal> x539=IKPowWithIntegerCheck(IKsign(new_r12),-1);
if(!x539.valid){
continue;
}
j33array[0]=((-1.5707963267949)+(x538.value)+(((1.5707963267949)*(x539.value))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x540=IKsin(j33);
IkReal x541=IKcos(j33);
IkReal x542=((1.0)*new_r12);
IkReal x543=((1.0)*x541);
IkReal x544=((1.0)*x540);
evalcond[0]=(((new_r12*x541))+new_r20);
evalcond[1]=(((new_r22*x540))+new_r11);
evalcond[2]=((((-1.0)*x540*x542))+new_r21);
evalcond[3]=((((-1.0)*new_r22*x543))+new_r10);
evalcond[4]=((((-1.0)*x544))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x543))+(((-1.0)*new_r01)));
evalcond[6]=((((-1.0)*new_r21*x542))+x540+((new_r11*new_r22)));
evalcond[7]=((((-1.0)*new_r20*x542))+(((-1.0)*x543))+((new_r10*new_r22)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x545=((((-1.0)*cj32))+new_r22);
IkReal x546=((1.0)*sj32);
IkReal x547=((1.0)*new_r12);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j31)))), 6.28318530717959)));
evalcond[1]=x545;
evalcond[2]=x545;
evalcond[3]=new_r02;
evalcond[4]=(sj32+new_r12);
evalcond[5]=((((-1.0)*x546))+(((-1.0)*x547)));
evalcond[6]=((((-1.0)*new_r10*x546))+((cj32*new_r20)));
evalcond[7]=((((-1.0)*new_r11*x546))+((cj32*new_r21)));
evalcond[8]=((-1.0)+(((-1.0)*new_r12*x546))+((cj32*new_r22)));
evalcond[9]=((((-1.0)*cj32*x547))+(((-1.0)*new_r22*x546)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r00, new_r01);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x548=IKsin(j33);
IkReal x549=IKcos(j33);
IkReal x550=((1.0)*new_r10);
IkReal x551=((1.0)*new_r11);
IkReal x552=((1.0)*x549);
evalcond[0]=(((new_r12*x548))+new_r21);
evalcond[1]=((((-1.0)*x548))+new_r00);
evalcond[2]=((((-1.0)*x552))+new_r01);
evalcond[3]=((((-1.0)*new_r12*x552))+new_r20);
evalcond[4]=((((-1.0)*x551))+((new_r22*x548)));
evalcond[5]=((((-1.0)*new_r22*x552))+(((-1.0)*x550)));
evalcond[6]=((((-1.0)*new_r22*x551))+((new_r12*new_r21))+x548);
evalcond[7]=((((-1.0)*new_r22*x550))+((new_r12*new_r20))+(((-1.0)*x552)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x553=((1.0)*sj31);
IkReal x554=(((cj31*new_r12))+(((-1.0)*new_r02*x553)));
IkReal x555=(((cj31*new_r00))+((new_r10*sj31)));
IkReal x556=(((cj31*new_r01))+((new_r11*sj31)));
IkReal x557=((-1.0)+((cj31*new_r02))+((new_r12*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j32)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=((((-1.0)*cj31))+new_r02);
evalcond[3]=((((-1.0)*x553))+new_r12);
evalcond[4]=x554;
evalcond[5]=x554;
evalcond[6]=x557;
evalcond[7]=x556;
evalcond[8]=x555;
evalcond[9]=x555;
evalcond[10]=x556;
evalcond[11]=x557;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x558=IKcos(j33);
IkReal x559=IKsin(j33);
IkReal x560=((1.0)*new_r12);
IkReal x561=((1.0)*x559);
IkReal x562=((1.0)*x558);
evalcond[0]=(x558+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x561)));
evalcond[2]=(((new_r12*x558))+new_r01);
evalcond[3]=(((new_r12*x559))+new_r00);
evalcond[4]=((((-1.0)*new_r02*x562))+new_r11);
evalcond[5]=((((-1.0)*new_r02*x561))+new_r10);
evalcond[6]=((((-1.0)*new_r00*x560))+((new_r02*new_r10))+(((-1.0)*x561)));
evalcond[7]=(((new_r02*new_r11))+(((-1.0)*x562))+(((-1.0)*new_r01*x560)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x563=(new_r10*sj31);
IkReal x564=(cj31*new_r00);
IkReal x565=(cj31*new_r02);
IkReal x566=(new_r11*sj31);
IkReal x567=(new_r12*sj31);
IkReal x568=(cj31*new_r01);
IkReal x569=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j32)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=(cj31+new_r02);
evalcond[3]=(sj31+new_r12);
evalcond[4]=x569;
evalcond[5]=x569;
evalcond[6]=((1.0)+x567+x565);
evalcond[7]=(x568+x566);
evalcond[8]=(x564+x563);
evalcond[9]=((((-1.0)*x563))+(((-1.0)*x564)));
evalcond[10]=((((-1.0)*x568))+(((-1.0)*x566)));
evalcond[11]=((-1.0)+(((-1.0)*x567))+(((-1.0)*x565)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x570=IKcos(j33);
IkReal x571=IKsin(j33);
IkReal x572=((1.0)*new_r02);
IkReal x573=((1.0)*x570);
IkReal x574=((1.0)*x571);
evalcond[0]=(x571+new_r21);
evalcond[1]=((((-1.0)*x573))+new_r20);
evalcond[2]=(new_r11+((new_r02*x570)));
evalcond[3]=(new_r10+((new_r02*x571)));
evalcond[4]=((((-1.0)*new_r12*x573))+new_r01);
evalcond[5]=((((-1.0)*new_r12*x574))+new_r00);
evalcond[6]=((((-1.0)*new_r10*x572))+((new_r00*new_r12))+(((-1.0)*x574)));
evalcond[7]=((((-1.0)*new_r11*x572))+((new_r01*new_r12))+(((-1.0)*x573)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x575=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
IkReal x576=(((cj31*new_r02))+((new_r12*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x575;
evalcond[7]=x575;
evalcond[8]=x576;
evalcond[9]=x576;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x577=((1.0)*sj31);
if( IKabs(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x577)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj31*new_r00))+(((-1.0)*new_r01*x577)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x577))))+IKsqr((((cj31*new_r00))+(((-1.0)*new_r01*x577))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x577))), (((cj31*new_r00))+(((-1.0)*new_r01*x577))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x578=IKsin(j33);
IkReal x579=IKcos(j33);
IkReal x580=((1.0)*sj31);
IkReal x581=((1.0)*x579);
IkReal x582=(sj31*x578);
IkReal x583=((1.0)*x578);
IkReal x584=(cj31*x581);
evalcond[0]=(((cj31*new_r01))+((new_r11*sj31))+x578);
evalcond[1]=(((cj31*x578))+new_r01+((sj31*x579)));
evalcond[2]=(((cj31*new_r00))+((new_r10*sj31))+(((-1.0)*x581)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x583))+(((-1.0)*new_r00*x580)));
evalcond[4]=((((-1.0)*new_r01*x580))+((cj31*new_r11))+(((-1.0)*x581)));
evalcond[5]=(x582+new_r00+(((-1.0)*x584)));
evalcond[6]=(x582+new_r11+(((-1.0)*x584)));
evalcond[7]=((((-1.0)*cj31*x583))+(((-1.0)*x579*x580))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x585=(cj31*new_r02);
IkReal x586=(new_r12*sj31);
IkReal x587=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x587;
evalcond[7]=x587;
evalcond[8]=(x585+x586);
evalcond[9]=((((-1.0)*x585))+(((-1.0)*x586)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x588=((1.0)*sj31);
if( IKabs((((cj31*new_r01))+(((-1.0)*new_r00*x588)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x588))+(((-1.0)*cj31*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj31*new_r01))+(((-1.0)*new_r00*x588))))+IKsqr(((((-1.0)*new_r01*x588))+(((-1.0)*cj31*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((((cj31*new_r01))+(((-1.0)*new_r00*x588))), ((((-1.0)*new_r01*x588))+(((-1.0)*cj31*new_r00))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x589=IKsin(j33);
IkReal x590=IKcos(j33);
IkReal x591=((1.0)*sj31);
IkReal x592=((1.0)*x589);
IkReal x593=(sj31*x590);
IkReal x594=((1.0)*x590);
IkReal x595=(cj31*x592);
evalcond[0]=(((cj31*new_r00))+((new_r10*sj31))+x590);
evalcond[1]=(((cj31*new_r01))+((new_r11*sj31))+(((-1.0)*x592)));
evalcond[2]=(((cj31*x590))+((sj31*x589))+new_r00);
evalcond[3]=((((-1.0)*new_r00*x591))+((cj31*new_r10))+(((-1.0)*x592)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*new_r01*x591))+(((-1.0)*x594)));
evalcond[5]=((((-1.0)*x595))+x593+new_r01);
evalcond[6]=((((-1.0)*x595))+x593+new_r10);
evalcond[7]=((((-1.0)*x589*x591))+new_r11+(((-1.0)*cj31*x594)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x596=((((-1.0)*cj32))+new_r22);
IkReal x597=((((-1.0)*sj32))+new_r02);
IkReal x598=((1.0)*sj32);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j31))), 6.28318530717959)));
evalcond[1]=x596;
evalcond[2]=x596;
evalcond[3]=x597;
evalcond[4]=new_r12;
evalcond[5]=x597;
evalcond[6]=(((new_r00*sj32))+((cj32*new_r20)));
evalcond[7]=(((new_r01*sj32))+((cj32*new_r21)));
evalcond[8]=((-1.0)+((new_r02*sj32))+((cj32*new_r22)));
evalcond[9]=(((cj32*new_r02))+(((-1.0)*new_r22*x598)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r10, new_r11);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x599=IKcos(j33);
IkReal x600=IKsin(j33);
IkReal x601=((1.0)*new_r02);
IkReal x602=((1.0)*x599);
evalcond[0]=(((new_r02*x599))+new_r20);
evalcond[1]=((((-1.0)*x600))+new_r10);
evalcond[2]=((((-1.0)*x602))+new_r11);
evalcond[3]=(((new_r22*x600))+new_r01);
evalcond[4]=((((-1.0)*x600*x601))+new_r21);
evalcond[5]=((((-1.0)*new_r22*x602))+new_r00);
evalcond[6]=(((new_r01*new_r22))+x600+(((-1.0)*new_r21*x601)));
evalcond[7]=((((-1.0)*new_r20*x601))+((new_r00*new_r22))+(((-1.0)*x602)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x603=((((-1.0)*cj32))+new_r22);
IkReal x604=((1.0)*sj32);
IkReal x605=((1.0)*new_r02);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j31)))), 6.28318530717959)));
evalcond[1]=x603;
evalcond[2]=x603;
evalcond[3]=(sj32+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((((-1.0)*x604))+(((-1.0)*x605)));
evalcond[6]=(((cj32*new_r20))+(((-1.0)*new_r00*x604)));
evalcond[7]=(((cj32*new_r21))+(((-1.0)*new_r01*x604)));
evalcond[8]=((-1.0)+(((-1.0)*new_r02*x604))+((cj32*new_r22)));
evalcond[9]=((((-1.0)*new_r22*x604))+(((-1.0)*cj32*x605)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x606 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),new_r20,IKFAST_ATAN2_MAGTHRESH);
if(!x606.valid){
continue;
}
CheckValue<IkReal> x607=IKPowWithIntegerCheck(IKsign(new_r02),-1);
if(!x607.valid){
continue;
}
j33array[0]=((-1.5707963267949)+(x606.value)+(((1.5707963267949)*(x607.value))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x608=IKsin(j33);
IkReal x609=IKcos(j33);
IkReal x610=((1.0)*new_r22);
IkReal x611=((1.0)*x609);
evalcond[0]=(((new_r02*x608))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x611))+new_r20);
evalcond[2]=((((-1.0)*x608))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x611))+(((-1.0)*new_r11)));
evalcond[4]=(((new_r22*x608))+(((-1.0)*new_r01)));
evalcond[5]=((((-1.0)*x609*x610))+(((-1.0)*new_r00)));
evalcond[6]=(x608+((new_r02*new_r21))+(((-1.0)*new_r01*x610)));
evalcond[7]=((((-1.0)*x611))+(((-1.0)*new_r00*x610))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j33]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x613=IKPowWithIntegerCheck(sj32,-1);
if(!x613.valid){
continue;
}
IkReal x612=x613.value;
CheckValue<IkReal> x614=IKPowWithIntegerCheck(cj31,-1);
if(!x614.valid){
continue;
}
CheckValue<IkReal> x615=IKPowWithIntegerCheck(cj32,-1);
if(!x615.valid){
continue;
}
if( IKabs((x612*(x614.value)*(x615.value)*((((new_r20*sj31))+(((-1.0)*new_r01*sj32)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x612)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x612*(x614.value)*(x615.value)*((((new_r20*sj31))+(((-1.0)*new_r01*sj32))))))+IKsqr(((-1.0)*new_r20*x612))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((x612*(x614.value)*(x615.value)*((((new_r20*sj31))+(((-1.0)*new_r01*sj32))))), ((-1.0)*new_r20*x612));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x616=IKsin(j33);
IkReal x617=IKcos(j33);
IkReal x618=(cj31*cj32);
IkReal x619=((1.0)*sj31);
IkReal x620=(new_r11*sj31);
IkReal x621=(new_r10*sj31);
IkReal x622=((1.0)*sj32);
IkReal x623=((1.0)*x617);
IkReal x624=((1.0)*x616);
IkReal x625=(sj31*x616);
evalcond[0]=(((sj32*x617))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x616*x622)));
evalcond[2]=(((cj31*new_r01))+((cj32*x616))+x620);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x624))+(((-1.0)*new_r00*x619)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x623))+(((-1.0)*new_r01*x619)));
evalcond[5]=(((x616*x618))+((sj31*x617))+new_r01);
evalcond[6]=(((cj31*new_r00))+(((-1.0)*cj32*x623))+x621);
evalcond[7]=(x625+(((-1.0)*x618*x623))+new_r00);
evalcond[8]=(((cj32*x625))+new_r11+(((-1.0)*cj31*x623)));
evalcond[9]=((((-1.0)*cj32*x617*x619))+new_r10+(((-1.0)*cj31*x624)));
evalcond[10]=((((-1.0)*new_r21*x622))+x616+((cj32*x620))+((new_r01*x618)));
evalcond[11]=((((-1.0)*x623))+(((-1.0)*new_r20*x622))+((cj32*x621))+((new_r00*x618)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x627=IKPowWithIntegerCheck(sj32,-1);
if(!x627.valid){
continue;
}
IkReal x626=x627.value;
CheckValue<IkReal> x628=IKPowWithIntegerCheck(sj31,-1);
if(!x628.valid){
continue;
}
if( IKabs((x626*(x628.value)*(((((-1.0)*new_r00*sj32))+(((-1.0)*cj31*cj32*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x626)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x626*(x628.value)*(((((-1.0)*new_r00*sj32))+(((-1.0)*cj31*cj32*new_r20))))))+IKsqr(((-1.0)*new_r20*x626))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((x626*(x628.value)*(((((-1.0)*new_r00*sj32))+(((-1.0)*cj31*cj32*new_r20))))), ((-1.0)*new_r20*x626));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x629=IKsin(j33);
IkReal x630=IKcos(j33);
IkReal x631=(cj31*cj32);
IkReal x632=((1.0)*sj31);
IkReal x633=(new_r11*sj31);
IkReal x634=(new_r10*sj31);
IkReal x635=((1.0)*sj32);
IkReal x636=((1.0)*x630);
IkReal x637=((1.0)*x629);
IkReal x638=(sj31*x629);
evalcond[0]=(((sj32*x630))+new_r20);
evalcond[1]=((((-1.0)*x629*x635))+new_r21);
evalcond[2]=(((cj31*new_r01))+x633+((cj32*x629)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x632))+(((-1.0)*x637)));
evalcond[4]=((((-1.0)*new_r01*x632))+((cj31*new_r11))+(((-1.0)*x636)));
evalcond[5]=(((x629*x631))+((sj31*x630))+new_r01);
evalcond[6]=(((cj31*new_r00))+(((-1.0)*cj32*x636))+x634);
evalcond[7]=((((-1.0)*x631*x636))+x638+new_r00);
evalcond[8]=((((-1.0)*cj31*x636))+new_r11+((cj32*x638)));
evalcond[9]=((((-1.0)*cj32*x630*x632))+(((-1.0)*cj31*x637))+new_r10);
evalcond[10]=(((new_r01*x631))+(((-1.0)*new_r21*x635))+x629+((cj32*x633)));
evalcond[11]=((((-1.0)*x636))+((new_r00*x631))+(((-1.0)*new_r20*x635))+((cj32*x634)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x639=IKPowWithIntegerCheck(IKsign(sj32),-1);
if(!x639.valid){
continue;
}
CheckValue<IkReal> x640 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x640.valid){
continue;
}
j33array[0]=((-1.5707963267949)+(((1.5707963267949)*(x639.value)))+(x640.value));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x641=IKsin(j33);
IkReal x642=IKcos(j33);
IkReal x643=(cj31*cj32);
IkReal x644=((1.0)*sj31);
IkReal x645=(new_r11*sj31);
IkReal x646=(new_r10*sj31);
IkReal x647=((1.0)*sj32);
IkReal x648=((1.0)*x642);
IkReal x649=((1.0)*x641);
IkReal x650=(sj31*x641);
evalcond[0]=(new_r20+((sj32*x642)));
evalcond[1]=((((-1.0)*x641*x647))+new_r21);
evalcond[2]=(((cj32*x641))+((cj31*new_r01))+x645);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x649))+(((-1.0)*new_r00*x644)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x648))+(((-1.0)*new_r01*x644)));
evalcond[5]=(((sj31*x642))+((x641*x643))+new_r01);
evalcond[6]=(((cj31*new_r00))+(((-1.0)*cj32*x648))+x646);
evalcond[7]=((((-1.0)*x643*x648))+x650+new_r00);
evalcond[8]=(((cj32*x650))+new_r11+(((-1.0)*cj31*x648)));
evalcond[9]=(new_r10+(((-1.0)*cj32*x642*x644))+(((-1.0)*cj31*x649)));
evalcond[10]=(((cj32*x645))+(((-1.0)*new_r21*x647))+((new_r01*x643))+x641);
evalcond[11]=(((cj32*x646))+(((-1.0)*x648))+((new_r00*x643))+(((-1.0)*new_r20*x647)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "ad4f1590d2a9b2079648c64e9db33191"; }

IKFAST_API const char* GetIkFastVersion() { return IKFAST_STRINGIZE(IKFAST_VERSION); }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif

#include "plugindefs.h" 
namespace IKFAST_NAMESPACE {
IkSolverBasePtr CreateIkSolver(EnvironmentBasePtr penv, std::istream& sinput, const std::vector<dReal>& vfreeinc) {
    boost::shared_ptr<ikfast::IkFastFunctions<IkReal> > ikfunctions(new ikfast::IkFastFunctions<IkReal>());
    ikfunctions->_ComputeIk = IKFAST_NAMESPACE::ComputeIk;
    ikfunctions->_ComputeFk = IKFAST_NAMESPACE::ComputeFk;
    ikfunctions->_GetNumFreeParameters = IKFAST_NAMESPACE::GetNumFreeParameters;
    ikfunctions->_GetFreeParameters = IKFAST_NAMESPACE::GetFreeParameters;
    ikfunctions->_GetNumJoints = IKFAST_NAMESPACE::GetNumJoints;
    ikfunctions->_GetIkRealSize = IKFAST_NAMESPACE::GetIkRealSize;
    ikfunctions->_GetIkFastVersion = IKFAST_NAMESPACE::GetIkFastVersion;
    ikfunctions->_GetIkType = IKFAST_NAMESPACE::GetIkType;
    ikfunctions->_GetKinematicsHash = IKFAST_NAMESPACE::GetKinematicsHash;
    return CreateIkFastSolver(penv,sinput,ikfunctions,vfreeinc);
}
} // end namespace
